// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  attribute: (where?: AttributeWhereInput) => Promise<boolean>;
  blockList: (where?: BlockListWhereInput) => Promise<boolean>;
  brand: (where?: BrandWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  conversation: (where?: ConversationWhereInput) => Promise<boolean>;
  conversationParticipant: (
    where?: ConversationParticipantWhereInput
  ) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  option: (where?: OptionWhereInput) => Promise<boolean>;
  optionValue: (where?: OptionValueWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  orderLineItem: (where?: OrderLineItemWhereInput) => Promise<boolean>;
  orderableProduct: (where?: OrderableProductWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  selectedOption: (where?: SelectedOptionWhereInput) => Promise<boolean>;
  shop: (where?: ShopWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  variant: (where?: VariantWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attribute: (where: AttributeWhereUniqueInput) => AttributeNullablePromise;
  attributes: (args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Attribute>;
  attributesConnection: (args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AttributeConnectionPromise;
  blockList: (where: BlockListWhereUniqueInput) => BlockListNullablePromise;
  blockLists: (args?: {
    where?: BlockListWhereInput;
    orderBy?: BlockListOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BlockList>;
  blockListsConnection: (args?: {
    where?: BlockListWhereInput;
    orderBy?: BlockListOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlockListConnectionPromise;
  brand: (where: BrandWhereUniqueInput) => BrandNullablePromise;
  brands: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Brand>;
  brandsConnection: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BrandConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  conversation: (
    where: ConversationWhereUniqueInput
  ) => ConversationNullablePromise;
  conversations: (args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Conversation>;
  conversationsConnection: (args?: {
    where?: ConversationWhereInput;
    orderBy?: ConversationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ConversationConnectionPromise;
  conversationParticipant: (
    where: ConversationParticipantWhereUniqueInput
  ) => ConversationParticipantNullablePromise;
  conversationParticipants: (args?: {
    where?: ConversationParticipantWhereInput;
    orderBy?: ConversationParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ConversationParticipant>;
  conversationParticipantsConnection: (args?: {
    where?: ConversationParticipantWhereInput;
    orderBy?: ConversationParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ConversationParticipantConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  option: (where: OptionWhereUniqueInput) => OptionNullablePromise;
  options: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Option>;
  optionsConnection: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptionConnectionPromise;
  optionValue: (
    where: OptionValueWhereUniqueInput
  ) => OptionValueNullablePromise;
  optionValues: (args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OptionValue>;
  optionValuesConnection: (args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptionValueConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  orderLineItem: (
    where: OrderLineItemWhereUniqueInput
  ) => OrderLineItemNullablePromise;
  orderLineItems: (args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderLineItem>;
  orderLineItemsConnection: (args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderLineItemConnectionPromise;
  orderableProduct: (
    where: OrderableProductWhereUniqueInput
  ) => OrderableProductNullablePromise;
  orderableProducts: (args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderableProduct>;
  orderableProductsConnection: (args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderableProductConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  selectedOption: (
    where: SelectedOptionWhereUniqueInput
  ) => SelectedOptionNullablePromise;
  selectedOptions: (args?: {
    where?: SelectedOptionWhereInput;
    orderBy?: SelectedOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SelectedOption>;
  selectedOptionsConnection: (args?: {
    where?: SelectedOptionWhereInput;
    orderBy?: SelectedOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SelectedOptionConnectionPromise;
  shop: (where: ShopWhereUniqueInput) => ShopNullablePromise;
  shops: (args?: {
    where?: ShopWhereInput;
    orderBy?: ShopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Shop>;
  shopsConnection: (args?: {
    where?: ShopWhereInput;
    orderBy?: ShopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShopConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  variant: (where: VariantWhereUniqueInput) => VariantNullablePromise;
  variants: (args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Variant>;
  variantsConnection: (args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VariantConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttribute: (data: AttributeCreateInput) => AttributePromise;
  updateAttribute: (args: {
    data: AttributeUpdateInput;
    where: AttributeWhereUniqueInput;
  }) => AttributePromise;
  updateManyAttributes: (args: {
    data: AttributeUpdateManyMutationInput;
    where?: AttributeWhereInput;
  }) => BatchPayloadPromise;
  upsertAttribute: (args: {
    where: AttributeWhereUniqueInput;
    create: AttributeCreateInput;
    update: AttributeUpdateInput;
  }) => AttributePromise;
  deleteAttribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  deleteManyAttributes: (where?: AttributeWhereInput) => BatchPayloadPromise;
  createBlockList: (data: BlockListCreateInput) => BlockListPromise;
  updateBlockList: (args: {
    data: BlockListUpdateInput;
    where: BlockListWhereUniqueInput;
  }) => BlockListPromise;
  upsertBlockList: (args: {
    where: BlockListWhereUniqueInput;
    create: BlockListCreateInput;
    update: BlockListUpdateInput;
  }) => BlockListPromise;
  deleteBlockList: (where: BlockListWhereUniqueInput) => BlockListPromise;
  deleteManyBlockLists: (where?: BlockListWhereInput) => BatchPayloadPromise;
  createBrand: (data: BrandCreateInput) => BrandPromise;
  updateBrand: (args: {
    data: BrandUpdateInput;
    where: BrandWhereUniqueInput;
  }) => BrandPromise;
  updateManyBrands: (args: {
    data: BrandUpdateManyMutationInput;
    where?: BrandWhereInput;
  }) => BatchPayloadPromise;
  upsertBrand: (args: {
    where: BrandWhereUniqueInput;
    create: BrandCreateInput;
    update: BrandUpdateInput;
  }) => BrandPromise;
  deleteBrand: (where: BrandWhereUniqueInput) => BrandPromise;
  deleteManyBrands: (where?: BrandWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createConversation: (data: ConversationCreateInput) => ConversationPromise;
  updateConversation: (args: {
    data: ConversationUpdateInput;
    where: ConversationWhereUniqueInput;
  }) => ConversationPromise;
  updateManyConversations: (args: {
    data: ConversationUpdateManyMutationInput;
    where?: ConversationWhereInput;
  }) => BatchPayloadPromise;
  upsertConversation: (args: {
    where: ConversationWhereUniqueInput;
    create: ConversationCreateInput;
    update: ConversationUpdateInput;
  }) => ConversationPromise;
  deleteConversation: (
    where: ConversationWhereUniqueInput
  ) => ConversationPromise;
  deleteManyConversations: (
    where?: ConversationWhereInput
  ) => BatchPayloadPromise;
  createConversationParticipant: (
    data: ConversationParticipantCreateInput
  ) => ConversationParticipantPromise;
  updateConversationParticipant: (args: {
    data: ConversationParticipantUpdateInput;
    where: ConversationParticipantWhereUniqueInput;
  }) => ConversationParticipantPromise;
  updateManyConversationParticipants: (args: {
    data: ConversationParticipantUpdateManyMutationInput;
    where?: ConversationParticipantWhereInput;
  }) => BatchPayloadPromise;
  upsertConversationParticipant: (args: {
    where: ConversationParticipantWhereUniqueInput;
    create: ConversationParticipantCreateInput;
    update: ConversationParticipantUpdateInput;
  }) => ConversationParticipantPromise;
  deleteConversationParticipant: (
    where: ConversationParticipantWhereUniqueInput
  ) => ConversationParticipantPromise;
  deleteManyConversationParticipants: (
    where?: ConversationParticipantWhereInput
  ) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createOption: (data: OptionCreateInput) => OptionPromise;
  updateOption: (args: {
    data: OptionUpdateInput;
    where: OptionWhereUniqueInput;
  }) => OptionPromise;
  updateManyOptions: (args: {
    data: OptionUpdateManyMutationInput;
    where?: OptionWhereInput;
  }) => BatchPayloadPromise;
  upsertOption: (args: {
    where: OptionWhereUniqueInput;
    create: OptionCreateInput;
    update: OptionUpdateInput;
  }) => OptionPromise;
  deleteOption: (where: OptionWhereUniqueInput) => OptionPromise;
  deleteManyOptions: (where?: OptionWhereInput) => BatchPayloadPromise;
  createOptionValue: (data: OptionValueCreateInput) => OptionValuePromise;
  updateOptionValue: (args: {
    data: OptionValueUpdateInput;
    where: OptionValueWhereUniqueInput;
  }) => OptionValuePromise;
  updateManyOptionValues: (args: {
    data: OptionValueUpdateManyMutationInput;
    where?: OptionValueWhereInput;
  }) => BatchPayloadPromise;
  upsertOptionValue: (args: {
    where: OptionValueWhereUniqueInput;
    create: OptionValueCreateInput;
    update: OptionValueUpdateInput;
  }) => OptionValuePromise;
  deleteOptionValue: (where: OptionValueWhereUniqueInput) => OptionValuePromise;
  deleteManyOptionValues: (
    where?: OptionValueWhereInput
  ) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createOrderLineItem: (data: OrderLineItemCreateInput) => OrderLineItemPromise;
  updateOrderLineItem: (args: {
    data: OrderLineItemUpdateInput;
    where: OrderLineItemWhereUniqueInput;
  }) => OrderLineItemPromise;
  updateManyOrderLineItems: (args: {
    data: OrderLineItemUpdateManyMutationInput;
    where?: OrderLineItemWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderLineItem: (args: {
    where: OrderLineItemWhereUniqueInput;
    create: OrderLineItemCreateInput;
    update: OrderLineItemUpdateInput;
  }) => OrderLineItemPromise;
  deleteOrderLineItem: (
    where: OrderLineItemWhereUniqueInput
  ) => OrderLineItemPromise;
  deleteManyOrderLineItems: (
    where?: OrderLineItemWhereInput
  ) => BatchPayloadPromise;
  createOrderableProduct: (
    data: OrderableProductCreateInput
  ) => OrderableProductPromise;
  updateOrderableProduct: (args: {
    data: OrderableProductUpdateInput;
    where: OrderableProductWhereUniqueInput;
  }) => OrderableProductPromise;
  updateManyOrderableProducts: (args: {
    data: OrderableProductUpdateManyMutationInput;
    where?: OrderableProductWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderableProduct: (args: {
    where: OrderableProductWhereUniqueInput;
    create: OrderableProductCreateInput;
    update: OrderableProductUpdateInput;
  }) => OrderableProductPromise;
  deleteOrderableProduct: (
    where: OrderableProductWhereUniqueInput
  ) => OrderableProductPromise;
  deleteManyOrderableProducts: (
    where?: OrderableProductWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createSelectedOption: (
    data: SelectedOptionCreateInput
  ) => SelectedOptionPromise;
  updateSelectedOption: (args: {
    data: SelectedOptionUpdateInput;
    where: SelectedOptionWhereUniqueInput;
  }) => SelectedOptionPromise;
  updateManySelectedOptions: (args: {
    data: SelectedOptionUpdateManyMutationInput;
    where?: SelectedOptionWhereInput;
  }) => BatchPayloadPromise;
  upsertSelectedOption: (args: {
    where: SelectedOptionWhereUniqueInput;
    create: SelectedOptionCreateInput;
    update: SelectedOptionUpdateInput;
  }) => SelectedOptionPromise;
  deleteSelectedOption: (
    where: SelectedOptionWhereUniqueInput
  ) => SelectedOptionPromise;
  deleteManySelectedOptions: (
    where?: SelectedOptionWhereInput
  ) => BatchPayloadPromise;
  createShop: (data: ShopCreateInput) => ShopPromise;
  updateShop: (args: {
    data: ShopUpdateInput;
    where: ShopWhereUniqueInput;
  }) => ShopPromise;
  updateManyShops: (args: {
    data: ShopUpdateManyMutationInput;
    where?: ShopWhereInput;
  }) => BatchPayloadPromise;
  upsertShop: (args: {
    where: ShopWhereUniqueInput;
    create: ShopCreateInput;
    update: ShopUpdateInput;
  }) => ShopPromise;
  deleteShop: (where: ShopWhereUniqueInput) => ShopPromise;
  deleteManyShops: (where?: ShopWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVariant: (data: VariantCreateInput) => VariantPromise;
  updateVariant: (args: {
    data: VariantUpdateInput;
    where: VariantWhereUniqueInput;
  }) => VariantPromise;
  updateManyVariants: (args: {
    data: VariantUpdateManyMutationInput;
    where?: VariantWhereInput;
  }) => BatchPayloadPromise;
  upsertVariant: (args: {
    where: VariantWhereUniqueInput;
    create: VariantCreateInput;
    update: VariantUpdateInput;
  }) => VariantPromise;
  deleteVariant: (where: VariantWhereUniqueInput) => VariantPromise;
  deleteManyVariants: (where?: VariantWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attribute: (
    where?: AttributeSubscriptionWhereInput
  ) => AttributeSubscriptionPayloadSubscription;
  blockList: (
    where?: BlockListSubscriptionWhereInput
  ) => BlockListSubscriptionPayloadSubscription;
  brand: (
    where?: BrandSubscriptionWhereInput
  ) => BrandSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  conversation: (
    where?: ConversationSubscriptionWhereInput
  ) => ConversationSubscriptionPayloadSubscription;
  conversationParticipant: (
    where?: ConversationParticipantSubscriptionWhereInput
  ) => ConversationParticipantSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  option: (
    where?: OptionSubscriptionWhereInput
  ) => OptionSubscriptionPayloadSubscription;
  optionValue: (
    where?: OptionValueSubscriptionWhereInput
  ) => OptionValueSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  orderLineItem: (
    where?: OrderLineItemSubscriptionWhereInput
  ) => OrderLineItemSubscriptionPayloadSubscription;
  orderableProduct: (
    where?: OrderableProductSubscriptionWhereInput
  ) => OrderableProductSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  selectedOption: (
    where?: SelectedOptionSubscriptionWhereInput
  ) => SelectedOptionSubscriptionPayloadSubscription;
  shop: (
    where?: ShopSubscriptionWhereInput
  ) => ShopSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  variant: (
    where?: VariantSubscriptionWhereInput
  ) => VariantSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ConversationParticipantRole = "MEMBER" | "ADMIN";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "SKU_ASC"
  | "SKU_DESC"
  | "displayPrice_ASC"
  | "displayPrice_DESC"
  | "available_ASC"
  | "available_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC";

export type MessageType = "TEXT" | "IMAGE" | "VIDEO" | "AUDIO" | "FILE";

export type ShopOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "zipCode_ASC"
  | "zipCode_DESC"
  | "city_ASC"
  | "city_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "openingHours_ASC"
  | "openingHours_DESC"
  | "MOTD_ASC"
  | "MOTD_DESC";

export type ConversationType = "SINGLE" | "GROUP";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderStatus = "SUBMITTED" | "PAID" | "PREPARED" | "FAILED";

export type BlockListOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRole = "USER" | "MODERATOR" | "ADMIN";

export type OrderLineItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "quantity_ASC"
  | "quantity_DESC";

export type OrderableProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "position_ASC"
  | "position_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "messageType_ASC"
  | "messageType_DESC"
  | "message_ASC"
  | "message_DESC"
  | "attachmentThumbUrl_ASC"
  | "attachmentThumbUrl_DESC"
  | "attachmentUrl_ASC"
  | "attachmentUrl_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC";

export type OptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type VariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "price_ASC"
  | "price_DESC"
  | "available_ASC"
  | "available_DESC";

export type SelectedOptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC";

export type OptionValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type AttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC";

export type ConversationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "conversationType_ASC"
  | "conversationType_DESC";

export type ConversationParticipantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "role_ASC"
  | "role_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "emailVerified_ASC"
  | "emailVerified_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "last_login_date_ASC"
  | "last_login_date_DESC"
  | "stripeCustomerId_ASC"
  | "stripeCustomerId_DESC"
  | "oneSignalUserId_ASC"
  | "oneSignalUserId_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "totalPrice_ASC"
  | "totalPrice_DESC"
  | "totalRefunded_ASC"
  | "totalRefunded_DESC"
  | "totalTax_ASC"
  | "totalTax_DESC"
  | "orderStatus_ASC"
  | "orderStatus_DESC";

export type BrandOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export interface ShopUpdateOneWithoutBestSellerProductsInput {
  create?: Maybe<ShopCreateWithoutBestSellerProductsInput>;
  update?: Maybe<ShopUpdateWithoutBestSellerProductsDataInput>;
  upsert?: Maybe<ShopUpsertWithoutBestSellerProductsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export type AttributeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductUpdateWithoutShopDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredInput>;
  SKU?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  options?: Maybe<OptionUpdateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueUpdateManyInput>;
  variants?: Maybe<VariantUpdateManyWithoutProductInput>;
  attributes?: Maybe<AttributeUpdateManyWithoutProductsInput>;
  displayPrice?: Maybe<Float>;
  available?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
  orderables?: Maybe<OrderableProductUpdateManyWithoutProductInput>;
}

export interface ConversationCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  creator: UserCreateOneInput;
  participants?: Maybe<
    ConversationParticipantCreateManyWithoutConversationInput
  >;
  conversationType: ConversationType;
  messages?: Maybe<MessageCreateManyWithoutConversationInput>;
}

export interface BrandUpdateOneRequiredInput {
  create?: Maybe<BrandCreateInput>;
  update?: Maybe<BrandUpdateDataInput>;
  upsert?: Maybe<BrandUpsertNestedInput>;
  connect?: Maybe<BrandWhereUniqueInput>;
}

export interface ShopUpdateOneWithoutNewProductsInput {
  create?: Maybe<ShopCreateWithoutNewProductsInput>;
  update?: Maybe<ShopUpdateWithoutNewProductsDataInput>;
  upsert?: Maybe<ShopUpsertWithoutNewProductsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export interface BrandUpdateDataInput {
  name?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface BrandUpsertNestedInput {
  update: BrandUpdateDataInput;
  create: BrandCreateInput;
}

export interface SelectedOptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SelectedOptionWhereInput>;
  AND?: Maybe<
    | SelectedOptionSubscriptionWhereInput[]
    | SelectedOptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SelectedOptionSubscriptionWhereInput[]
    | SelectedOptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SelectedOptionSubscriptionWhereInput[]
    | SelectedOptionSubscriptionWhereInput
  >;
}

export interface OptionUpdateManyInput {
  create?: Maybe<OptionCreateInput[] | OptionCreateInput>;
  update?: Maybe<
    | OptionUpdateWithWhereUniqueNestedInput[]
    | OptionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | OptionUpsertWithWhereUniqueNestedInput[]
    | OptionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  connect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  set?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  disconnect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  deleteMany?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
  updateMany?: Maybe<
    | OptionUpdateManyWithWhereNestedInput[]
    | OptionUpdateManyWithWhereNestedInput
  >;
}

export interface OrderableProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderableProductWhereInput>;
  AND?: Maybe<
    | OrderableProductSubscriptionWhereInput[]
    | OrderableProductSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OrderableProductSubscriptionWhereInput[]
    | OrderableProductSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OrderableProductSubscriptionWhereInput[]
    | OrderableProductSubscriptionWhereInput
  >;
}

export interface OptionUpdateWithWhereUniqueNestedInput {
  where: OptionWhereUniqueInput;
  data: OptionUpdateDataInput;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface OptionUpdateDataInput {
  name?: Maybe<String>;
  values?: Maybe<OptionValueUpdateManyInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutOptionsInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface OptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OptionWhereInput>;
  AND?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
  OR?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
  NOT?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
}

export interface CategoryUpdateOneRequiredWithoutOptionsInput {
  create?: Maybe<CategoryCreateWithoutOptionsInput>;
  update?: Maybe<CategoryUpdateWithoutOptionsDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutOptionsInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export type BlockListWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CategoryUpdateWithoutOptionsDataInput {
  name?: Maybe<String>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface ConversationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ConversationWhereInput>;
  AND?: Maybe<
    ConversationSubscriptionWhereInput[] | ConversationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ConversationSubscriptionWhereInput[] | ConversationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ConversationSubscriptionWhereInput[] | ConversationSubscriptionWhereInput
  >;
}

export interface CategoryUpsertWithoutOptionsInput {
  update: CategoryUpdateWithoutOptionsDataInput;
  create: CategoryCreateWithoutOptionsInput;
}

export interface ConversationParticipantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  conversation?: Maybe<ConversationWhereInput>;
  role?: Maybe<ConversationParticipantRole>;
  role_not?: Maybe<ConversationParticipantRole>;
  role_in?: Maybe<ConversationParticipantRole[] | ConversationParticipantRole>;
  role_not_in?: Maybe<
    ConversationParticipantRole[] | ConversationParticipantRole
  >;
  AND?: Maybe<
    ConversationParticipantWhereInput[] | ConversationParticipantWhereInput
  >;
  OR?: Maybe<
    ConversationParticipantWhereInput[] | ConversationParticipantWhereInput
  >;
  NOT?: Maybe<
    ConversationParticipantWhereInput[] | ConversationParticipantWhereInput
  >;
}

export interface OptionUpsertWithWhereUniqueNestedInput {
  where: OptionWhereUniqueInput;
  update: OptionUpdateDataInput;
  create: OptionCreateInput;
}

export interface OrderLineItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  variant?: Maybe<VariantWhereInput>;
  owner?: Maybe<UserWhereInput>;
  shop?: Maybe<ShopWhereInput>;
  AND?: Maybe<OrderLineItemWhereInput[] | OrderLineItemWhereInput>;
  OR?: Maybe<OrderLineItemWhereInput[] | OrderLineItemWhereInput>;
  NOT?: Maybe<OrderLineItemWhereInput[] | OrderLineItemWhereInput>;
}

export interface OptionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
  OR?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
  NOT?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
}

export interface AttributeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  category?: Maybe<CategoryWhereInput>;
  shop?: Maybe<ShopWhereInput>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<AttributeWhereInput[] | AttributeWhereInput>;
  OR?: Maybe<AttributeWhereInput[] | AttributeWhereInput>;
  NOT?: Maybe<AttributeWhereInput[] | AttributeWhereInput>;
}

export interface OptionUpdateManyWithWhereNestedInput {
  where: OptionScalarWhereInput;
  data: OptionUpdateManyDataInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface OptionUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface BrandSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BrandWhereInput>;
  AND?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
  OR?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
  NOT?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
}

export interface VariantUpdateManyWithoutProductInput {
  create?: Maybe<
    VariantCreateWithoutProductInput[] | VariantCreateWithoutProductInput
  >;
  delete?: Maybe<VariantWhereUniqueInput[] | VariantWhereUniqueInput>;
  connect?: Maybe<VariantWhereUniqueInput[] | VariantWhereUniqueInput>;
  set?: Maybe<VariantWhereUniqueInput[] | VariantWhereUniqueInput>;
  disconnect?: Maybe<VariantWhereUniqueInput[] | VariantWhereUniqueInput>;
  update?: Maybe<
    | VariantUpdateWithWhereUniqueWithoutProductInput[]
    | VariantUpdateWithWhereUniqueWithoutProductInput
  >;
  upsert?: Maybe<
    | VariantUpsertWithWhereUniqueWithoutProductInput[]
    | VariantUpsertWithWhereUniqueWithoutProductInput
  >;
  deleteMany?: Maybe<VariantScalarWhereInput[] | VariantScalarWhereInput>;
  updateMany?: Maybe<
    | VariantUpdateManyWithWhereNestedInput[]
    | VariantUpdateManyWithWhereNestedInput
  >;
}

export interface VariantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  selectedOptions_every?: Maybe<SelectedOptionWhereInput>;
  selectedOptions_some?: Maybe<SelectedOptionWhereInput>;
  selectedOptions_none?: Maybe<SelectedOptionWhereInput>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  product?: Maybe<ProductWhereInput>;
  AND?: Maybe<VariantWhereInput[] | VariantWhereInput>;
  OR?: Maybe<VariantWhereInput[] | VariantWhereInput>;
  NOT?: Maybe<VariantWhereInput[] | VariantWhereInput>;
}

export interface VariantUpdateWithWhereUniqueWithoutProductInput {
  where: VariantWhereUniqueInput;
  data: VariantUpdateWithoutProductDataInput;
}

export interface AttributeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AttributeWhereInput>;
  AND?: Maybe<
    AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput
  >;
  OR?: Maybe<
    AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput
  >;
}

export interface VariantUpdateWithoutProductDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  selectedOptions?: Maybe<SelectedOptionUpdateManyWithoutVariantInput>;
  price?: Maybe<Float>;
  available?: Maybe<Boolean>;
}

export interface VariantUpdateManyMutationInput {
  deletedAt?: Maybe<DateTimeInput>;
  price?: Maybe<Float>;
  available?: Maybe<Boolean>;
}

export interface SelectedOptionUpdateManyWithoutVariantInput {
  create?: Maybe<
    | SelectedOptionCreateWithoutVariantInput[]
    | SelectedOptionCreateWithoutVariantInput
  >;
  delete?: Maybe<
    SelectedOptionWhereUniqueInput[] | SelectedOptionWhereUniqueInput
  >;
  connect?: Maybe<
    SelectedOptionWhereUniqueInput[] | SelectedOptionWhereUniqueInput
  >;
  set?: Maybe<
    SelectedOptionWhereUniqueInput[] | SelectedOptionWhereUniqueInput
  >;
  disconnect?: Maybe<
    SelectedOptionWhereUniqueInput[] | SelectedOptionWhereUniqueInput
  >;
  update?: Maybe<
    | SelectedOptionUpdateWithWhereUniqueWithoutVariantInput[]
    | SelectedOptionUpdateWithWhereUniqueWithoutVariantInput
  >;
  upsert?: Maybe<
    | SelectedOptionUpsertWithWhereUniqueWithoutVariantInput[]
    | SelectedOptionUpsertWithWhereUniqueWithoutVariantInput
  >;
  deleteMany?: Maybe<
    SelectedOptionScalarWhereInput[] | SelectedOptionScalarWhereInput
  >;
  updateMany?: Maybe<
    | SelectedOptionUpdateManyWithWhereNestedInput[]
    | SelectedOptionUpdateManyWithWhereNestedInput
  >;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  shop?: Maybe<ShopWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  brand?: Maybe<BrandWhereInput>;
  SKU?: Maybe<String>;
  SKU_not?: Maybe<String>;
  SKU_in?: Maybe<String[] | String>;
  SKU_not_in?: Maybe<String[] | String>;
  SKU_lt?: Maybe<String>;
  SKU_lte?: Maybe<String>;
  SKU_gt?: Maybe<String>;
  SKU_gte?: Maybe<String>;
  SKU_contains?: Maybe<String>;
  SKU_not_contains?: Maybe<String>;
  SKU_starts_with?: Maybe<String>;
  SKU_not_starts_with?: Maybe<String>;
  SKU_ends_with?: Maybe<String>;
  SKU_not_ends_with?: Maybe<String>;
  category?: Maybe<CategoryWhereInput>;
  options_every?: Maybe<OptionWhereInput>;
  options_some?: Maybe<OptionWhereInput>;
  options_none?: Maybe<OptionWhereInput>;
  unavailableOptionsValues_every?: Maybe<OptionValueWhereInput>;
  unavailableOptionsValues_some?: Maybe<OptionValueWhereInput>;
  unavailableOptionsValues_none?: Maybe<OptionValueWhereInput>;
  variants_every?: Maybe<VariantWhereInput>;
  variants_some?: Maybe<VariantWhereInput>;
  variants_none?: Maybe<VariantWhereInput>;
  attributes_every?: Maybe<AttributeWhereInput>;
  attributes_some?: Maybe<AttributeWhereInput>;
  attributes_none?: Maybe<AttributeWhereInput>;
  displayPrice?: Maybe<Float>;
  displayPrice_not?: Maybe<Float>;
  displayPrice_in?: Maybe<Float[] | Float>;
  displayPrice_not_in?: Maybe<Float[] | Float>;
  displayPrice_lt?: Maybe<Float>;
  displayPrice_lte?: Maybe<Float>;
  displayPrice_gt?: Maybe<Float>;
  displayPrice_gte?: Maybe<Float>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  orderables_every?: Maybe<OrderableProductWhereInput>;
  orderables_some?: Maybe<OrderableProductWhereInput>;
  orderables_none?: Maybe<OrderableProductWhereInput>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface SelectedOptionUpdateWithWhereUniqueWithoutVariantInput {
  where: SelectedOptionWhereUniqueInput;
  data: SelectedOptionUpdateWithoutVariantDataInput;
}

export interface ShopWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  openingHours?: Maybe<String>;
  openingHours_not?: Maybe<String>;
  openingHours_in?: Maybe<String[] | String>;
  openingHours_not_in?: Maybe<String[] | String>;
  openingHours_lt?: Maybe<String>;
  openingHours_lte?: Maybe<String>;
  openingHours_gt?: Maybe<String>;
  openingHours_gte?: Maybe<String>;
  openingHours_contains?: Maybe<String>;
  openingHours_not_contains?: Maybe<String>;
  openingHours_starts_with?: Maybe<String>;
  openingHours_not_starts_with?: Maybe<String>;
  openingHours_ends_with?: Maybe<String>;
  openingHours_not_ends_with?: Maybe<String>;
  MOTD?: Maybe<String>;
  MOTD_not?: Maybe<String>;
  MOTD_in?: Maybe<String[] | String>;
  MOTD_not_in?: Maybe<String[] | String>;
  MOTD_lt?: Maybe<String>;
  MOTD_lte?: Maybe<String>;
  MOTD_gt?: Maybe<String>;
  MOTD_gte?: Maybe<String>;
  MOTD_contains?: Maybe<String>;
  MOTD_not_contains?: Maybe<String>;
  MOTD_starts_with?: Maybe<String>;
  MOTD_not_starts_with?: Maybe<String>;
  MOTD_ends_with?: Maybe<String>;
  MOTD_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  newProducts_every?: Maybe<OrderableProductWhereInput>;
  newProducts_some?: Maybe<OrderableProductWhereInput>;
  newProducts_none?: Maybe<OrderableProductWhereInput>;
  bestSellerProducts_every?: Maybe<OrderableProductWhereInput>;
  bestSellerProducts_some?: Maybe<OrderableProductWhereInput>;
  bestSellerProducts_none?: Maybe<OrderableProductWhereInput>;
  AND?: Maybe<ShopWhereInput[] | ShopWhereInput>;
  OR?: Maybe<ShopWhereInput[] | ShopWhereInput>;
  NOT?: Maybe<ShopWhereInput[] | ShopWhereInput>;
}

export interface SelectedOptionUpdateWithoutVariantDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  option?: Maybe<OptionUpdateOneRequiredInput>;
  value?: Maybe<OptionValueUpdateOneRequiredInput>;
}

export interface BlockListWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  blockedUser?: Maybe<UserWhereInput>;
  AND?: Maybe<BlockListWhereInput[] | BlockListWhereInput>;
  OR?: Maybe<BlockListWhereInput[] | BlockListWhereInput>;
  NOT?: Maybe<BlockListWhereInput[] | BlockListWhereInput>;
}

export interface OptionUpdateOneRequiredInput {
  create?: Maybe<OptionCreateInput>;
  update?: Maybe<OptionUpdateDataInput>;
  upsert?: Maybe<OptionUpsertNestedInput>;
  connect?: Maybe<OptionWhereUniqueInput>;
}

export interface ShopUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  openingHours?: Maybe<String>;
  MOTD?: Maybe<String>;
}

export interface OptionUpsertNestedInput {
  update: OptionUpdateDataInput;
  create: OptionCreateInput;
}

export interface SelectedOptionUpdateManyMutationInput {
  deletedAt?: Maybe<DateTimeInput>;
}

export interface OptionValueUpdateOneRequiredInput {
  create?: Maybe<OptionValueCreateInput>;
  update?: Maybe<OptionValueUpdateDataInput>;
  upsert?: Maybe<OptionValueUpsertNestedInput>;
  connect?: Maybe<OptionValueWhereUniqueInput>;
}

export interface OptionValueWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<OptionValueWhereInput[] | OptionValueWhereInput>;
  OR?: Maybe<OptionValueWhereInput[] | OptionValueWhereInput>;
  NOT?: Maybe<OptionValueWhereInput[] | OptionValueWhereInput>;
}

export interface OptionValueUpsertNestedInput {
  update: OptionValueUpdateDataInput;
  create: OptionValueCreateInput;
}

export interface VariantUpdateWithoutSelectedOptionsDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  price?: Maybe<Float>;
  available?: Maybe<Boolean>;
  product?: Maybe<ProductUpdateOneWithoutVariantsInput>;
}

export interface SelectedOptionUpsertWithWhereUniqueWithoutVariantInput {
  where: SelectedOptionWhereUniqueInput;
  update: SelectedOptionUpdateWithoutVariantDataInput;
  create: SelectedOptionCreateWithoutVariantInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SelectedOptionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    SelectedOptionScalarWhereInput[] | SelectedOptionScalarWhereInput
  >;
  OR?: Maybe<SelectedOptionScalarWhereInput[] | SelectedOptionScalarWhereInput>;
  NOT?: Maybe<
    SelectedOptionScalarWhereInput[] | SelectedOptionScalarWhereInput
  >;
}

export interface SelectedOptionUpdateInput {
  deletedAt?: Maybe<DateTimeInput>;
  option?: Maybe<OptionUpdateOneRequiredInput>;
  variant?: Maybe<VariantUpdateOneRequiredWithoutSelectedOptionsInput>;
  value?: Maybe<OptionValueUpdateOneRequiredInput>;
}

export interface SelectedOptionUpdateManyWithWhereNestedInput {
  where: SelectedOptionScalarWhereInput;
  data: SelectedOptionUpdateManyDataInput;
}

export interface VariantCreateOneWithoutSelectedOptionsInput {
  create?: Maybe<VariantCreateWithoutSelectedOptionsInput>;
  connect?: Maybe<VariantWhereUniqueInput>;
}

export interface SelectedOptionUpdateManyDataInput {
  deletedAt?: Maybe<DateTimeInput>;
}

export interface SelectedOptionCreateInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  option: OptionCreateOneInput;
  variant: VariantCreateOneWithoutSelectedOptionsInput;
  value: OptionValueCreateOneInput;
}

export interface VariantUpsertWithWhereUniqueWithoutProductInput {
  where: VariantWhereUniqueInput;
  update: VariantUpdateWithoutProductDataInput;
  create: VariantCreateWithoutProductInput;
}

export interface ProductUpdateInput {
  deletedAt?: Maybe<DateTimeInput>;
  shop?: Maybe<ShopUpdateOneRequiredWithoutProductsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredInput>;
  SKU?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  options?: Maybe<OptionUpdateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueUpdateManyInput>;
  variants?: Maybe<VariantUpdateManyWithoutProductInput>;
  attributes?: Maybe<AttributeUpdateManyWithoutProductsInput>;
  displayPrice?: Maybe<Float>;
  available?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
  orderables?: Maybe<OrderableProductUpdateManyWithoutProductInput>;
}

export interface VariantScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<VariantScalarWhereInput[] | VariantScalarWhereInput>;
  OR?: Maybe<VariantScalarWhereInput[] | VariantScalarWhereInput>;
  NOT?: Maybe<VariantScalarWhereInput[] | VariantScalarWhereInput>;
}

export type ConversationParticipantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface VariantUpdateManyWithWhereNestedInput {
  where: VariantScalarWhereInput;
  data: VariantUpdateManyDataInput;
}

export interface OrderableProductUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredWithoutOrderablesInput>;
  position?: Maybe<Int>;
  shopBestSeller?: Maybe<ShopUpdateOneWithoutBestSellerProductsInput>;
  shopNewProduct?: Maybe<ShopUpdateOneWithoutNewProductsInput>;
}

export interface VariantUpdateManyDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  price?: Maybe<Float>;
  available?: Maybe<Boolean>;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AttributeUpdateManyWithoutProductsInput {
  create?: Maybe<
    AttributeCreateWithoutProductsInput[] | AttributeCreateWithoutProductsInput
  >;
  delete?: Maybe<AttributeWhereUniqueInput[] | AttributeWhereUniqueInput>;
  connect?: Maybe<AttributeWhereUniqueInput[] | AttributeWhereUniqueInput>;
  set?: Maybe<AttributeWhereUniqueInput[] | AttributeWhereUniqueInput>;
  disconnect?: Maybe<AttributeWhereUniqueInput[] | AttributeWhereUniqueInput>;
  update?: Maybe<
    | AttributeUpdateWithWhereUniqueWithoutProductsInput[]
    | AttributeUpdateWithWhereUniqueWithoutProductsInput
  >;
  upsert?: Maybe<
    | AttributeUpsertWithWhereUniqueWithoutProductsInput[]
    | AttributeUpsertWithWhereUniqueWithoutProductsInput
  >;
  deleteMany?: Maybe<AttributeScalarWhereInput[] | AttributeScalarWhereInput>;
  updateMany?: Maybe<
    | AttributeUpdateManyWithWhereNestedInput[]
    | AttributeUpdateManyWithWhereNestedInput
  >;
}

export interface OrderLineItemUpdateInput {
  deletedAt?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  variant?: Maybe<VariantUpdateOneInput>;
  owner?: Maybe<UserUpdateOneWithoutCartInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface AttributeUpdateWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput;
  data: AttributeUpdateWithoutProductsDataInput;
}

export type OptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AttributeUpdateWithoutProductsDataInput {
  value?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface UserUpdateWithoutOrdersDataInput {
  selectedShop?: Maybe<ShopUpdateOneInput>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  conversations?: Maybe<ConversationParticipantUpdateManyWithoutUserInput>;
  contacts?: Maybe<UserUpdateManyInput>;
  cart?: Maybe<OrderLineItemUpdateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface AttributeUpsertWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput;
  update: AttributeUpdateWithoutProductsDataInput;
  create: AttributeCreateWithoutProductsInput;
}

export type OptionValueWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AttributeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<AttributeScalarWhereInput[] | AttributeScalarWhereInput>;
  OR?: Maybe<AttributeScalarWhereInput[] | AttributeScalarWhereInput>;
  NOT?: Maybe<AttributeScalarWhereInput[] | AttributeScalarWhereInput>;
}

export interface UserCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  selectedShop?: Maybe<ShopCreateOneInput>;
  email: String;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserCreaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  conversations?: Maybe<ConversationParticipantCreateManyWithoutUserInput>;
  contacts?: Maybe<UserCreateManyInput>;
  cart?: Maybe<OrderLineItemCreateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface AttributeUpdateManyWithWhereNestedInput {
  where: AttributeScalarWhereInput;
  data: AttributeUpdateManyDataInput;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AttributeUpdateManyDataInput {
  value?: Maybe<String>;
}

export interface OptionValueUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface OrderableProductUpdateManyWithoutProductInput {
  create?: Maybe<
    | OrderableProductCreateWithoutProductInput[]
    | OrderableProductCreateWithoutProductInput
  >;
  delete?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  connect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  set?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  update?: Maybe<
    | OrderableProductUpdateWithWhereUniqueWithoutProductInput[]
    | OrderableProductUpdateWithWhereUniqueWithoutProductInput
  >;
  upsert?: Maybe<
    | OrderableProductUpsertWithWhereUniqueWithoutProductInput[]
    | OrderableProductUpsertWithWhereUniqueWithoutProductInput
  >;
  deleteMany?: Maybe<
    OrderableProductScalarWhereInput[] | OrderableProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | OrderableProductUpdateManyWithWhereNestedInput[]
    | OrderableProductUpdateManyWithWhereNestedInput
  >;
}

export type OrderLineItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrderableProductUpdateWithWhereUniqueWithoutProductInput {
  where: OrderableProductWhereUniqueInput;
  data: OrderableProductUpdateWithoutProductDataInput;
}

export interface OptionUpdateInput {
  name?: Maybe<String>;
  values?: Maybe<OptionValueUpdateManyInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutOptionsInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface OrderableProductUpdateWithoutProductDataInput {
  position?: Maybe<Int>;
  shopBestSeller?: Maybe<ShopUpdateOneWithoutBestSellerProductsInput>;
  shopNewProduct?: Maybe<ShopUpdateOneWithoutNewProductsInput>;
}

export type OrderableProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateWithoutConversationsInput {
  id?: Maybe<ID_Input>;
  selectedShop?: Maybe<ShopCreateOneInput>;
  email: String;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserCreaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  contacts?: Maybe<UserCreateManyInput>;
  cart?: Maybe<OrderLineItemCreateManyWithoutOwnerInput>;
  orders?: Maybe<OrderCreateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface ConversationUpdateWithoutMessagesDataInput {
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  participants?: Maybe<
    ConversationParticipantUpdateManyWithoutConversationInput
  >;
  conversationType?: Maybe<ConversationType>;
}

export interface ShopUpdateWithoutBestSellerProductsDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  openingHours?: Maybe<String>;
  MOTD?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutShopInput>;
  newProducts?: Maybe<OrderableProductUpdateManyWithoutShopNewProductInput>;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrderableProductUpdateManyWithoutShopNewProductInput {
  create?: Maybe<
    | OrderableProductCreateWithoutShopNewProductInput[]
    | OrderableProductCreateWithoutShopNewProductInput
  >;
  delete?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  connect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  set?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  update?: Maybe<
    | OrderableProductUpdateWithWhereUniqueWithoutShopNewProductInput[]
    | OrderableProductUpdateWithWhereUniqueWithoutShopNewProductInput
  >;
  upsert?: Maybe<
    | OrderableProductUpsertWithWhereUniqueWithoutShopNewProductInput[]
    | OrderableProductUpsertWithWhereUniqueWithoutShopNewProductInput
  >;
  deleteMany?: Maybe<
    OrderableProductScalarWhereInput[] | OrderableProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | OrderableProductUpdateManyWithWhereNestedInput[]
    | OrderableProductUpdateManyWithWhereNestedInput
  >;
}

export interface ConversationCreateWithoutMessagesInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  creator: UserCreateOneInput;
  participants?: Maybe<
    ConversationParticipantCreateManyWithoutConversationInput
  >;
  conversationType: ConversationType;
}

export interface OrderableProductUpdateWithWhereUniqueWithoutShopNewProductInput {
  where: OrderableProductWhereUniqueInput;
  data: OrderableProductUpdateWithoutShopNewProductDataInput;
}

export type SelectedOptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrderableProductUpdateWithoutShopNewProductDataInput {
  product?: Maybe<ProductUpdateOneRequiredWithoutOrderablesInput>;
  position?: Maybe<Int>;
  shopBestSeller?: Maybe<ShopUpdateOneWithoutBestSellerProductsInput>;
}

export interface ConversationParticipantUpdateManyMutationInput {
  role?: Maybe<ConversationParticipantRole>;
}

export interface ProductUpdateOneRequiredWithoutOrderablesInput {
  create?: Maybe<ProductCreateWithoutOrderablesInput>;
  update?: Maybe<ProductUpdateWithoutOrderablesDataInput>;
  upsert?: Maybe<ProductUpsertWithoutOrderablesInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export type ShopWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductUpdateWithoutOrderablesDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  shop?: Maybe<ShopUpdateOneRequiredWithoutProductsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredInput>;
  SKU?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  options?: Maybe<OptionUpdateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueUpdateManyInput>;
  variants?: Maybe<VariantUpdateManyWithoutProductInput>;
  attributes?: Maybe<AttributeUpdateManyWithoutProductsInput>;
  displayPrice?: Maybe<Float>;
  available?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
}

export interface ConversationUpdateManyMutationInput {
  title?: Maybe<String>;
  conversationType?: Maybe<ConversationType>;
}

export interface ShopUpdateOneRequiredWithoutProductsInput {
  create?: Maybe<ShopCreateWithoutProductsInput>;
  update?: Maybe<ShopUpdateWithoutProductsDataInput>;
  upsert?: Maybe<ShopUpsertWithoutProductsInput>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export interface UserUpsertWithoutConversationsInput {
  update: UserUpdateWithoutConversationsDataInput;
  create: UserCreateWithoutConversationsInput;
}

export interface ShopUpdateWithoutProductsDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  openingHours?: Maybe<String>;
  MOTD?: Maybe<String>;
  newProducts?: Maybe<OrderableProductUpdateManyWithoutShopNewProductInput>;
  bestSellerProducts?: Maybe<
    OrderableProductUpdateManyWithoutShopBestSellerInput
  >;
}

export interface UserUpdateWithoutConversationsDataInput {
  selectedShop?: Maybe<ShopUpdateOneInput>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  contacts?: Maybe<UserUpdateManyInput>;
  cart?: Maybe<OrderLineItemUpdateManyWithoutOwnerInput>;
  orders?: Maybe<OrderUpdateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface OrderableProductUpdateManyWithoutShopBestSellerInput {
  create?: Maybe<
    | OrderableProductCreateWithoutShopBestSellerInput[]
    | OrderableProductCreateWithoutShopBestSellerInput
  >;
  delete?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  connect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  set?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
  update?: Maybe<
    | OrderableProductUpdateWithWhereUniqueWithoutShopBestSellerInput[]
    | OrderableProductUpdateWithWhereUniqueWithoutShopBestSellerInput
  >;
  upsert?: Maybe<
    | OrderableProductUpsertWithWhereUniqueWithoutShopBestSellerInput[]
    | OrderableProductUpsertWithWhereUniqueWithoutShopBestSellerInput
  >;
  deleteMany?: Maybe<
    OrderableProductScalarWhereInput[] | OrderableProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | OrderableProductUpdateManyWithWhereNestedInput[]
    | OrderableProductUpdateManyWithWhereNestedInput
  >;
}

export interface ConversationParticipantUpdateWithoutConversationDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutConversationsInput>;
  role?: Maybe<ConversationParticipantRole>;
}

export interface OrderableProductUpdateWithWhereUniqueWithoutShopBestSellerInput {
  where: OrderableProductWhereUniqueInput;
  data: OrderableProductUpdateWithoutShopBestSellerDataInput;
}

export interface ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput {
  where: ConversationParticipantWhereUniqueInput;
  data: ConversationParticipantUpdateWithoutConversationDataInput;
}

export interface OrderableProductUpdateWithoutShopBestSellerDataInput {
  product?: Maybe<ProductUpdateOneRequiredWithoutOrderablesInput>;
  position?: Maybe<Int>;
  shopNewProduct?: Maybe<ShopUpdateOneWithoutNewProductsInput>;
}

export interface ConversationUpdateInput {
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  participants?: Maybe<
    ConversationParticipantUpdateManyWithoutConversationInput
  >;
  conversationType?: Maybe<ConversationType>;
  messages?: Maybe<MessageUpdateManyWithoutConversationInput>;
}

export interface UserCreateOneWithoutConversationsInput {
  create?: Maybe<UserCreateWithoutConversationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface AttributeCreateInput {
  id?: Maybe<ID_Input>;
  value: String;
  category: CategoryCreateOneInput;
  shop: ShopCreateOneInput;
  products?: Maybe<ProductCreateManyWithoutAttributesInput>;
}

export interface ShopUpdateWithoutNewProductsDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  openingHours?: Maybe<String>;
  MOTD?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutShopInput>;
  bestSellerProducts?: Maybe<
    OrderableProductUpdateManyWithoutShopBestSellerInput
  >;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  options?: Maybe<OptionCreateManyWithoutCategoryInput>;
  shop: ShopCreateOneInput;
}

export interface ShopUpsertWithoutNewProductsInput {
  update: ShopUpdateWithoutNewProductsDataInput;
  create: ShopCreateWithoutNewProductsInput;
}

export interface OptionCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  name: String;
  values?: Maybe<OptionValueCreateManyInput>;
  shop: ShopCreateOneInput;
}

export interface OrderableProductUpsertWithWhereUniqueWithoutShopBestSellerInput {
  where: OrderableProductWhereUniqueInput;
  update: OrderableProductUpdateWithoutShopBestSellerDataInput;
  create: OrderableProductCreateWithoutShopBestSellerInput;
}

export interface OptionValueCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface OrderableProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  position?: Maybe<Int>;
  position_not?: Maybe<Int>;
  position_in?: Maybe<Int[] | Int>;
  position_not_in?: Maybe<Int[] | Int>;
  position_lt?: Maybe<Int>;
  position_lte?: Maybe<Int>;
  position_gt?: Maybe<Int>;
  position_gte?: Maybe<Int>;
  AND?: Maybe<
    OrderableProductScalarWhereInput[] | OrderableProductScalarWhereInput
  >;
  OR?: Maybe<
    OrderableProductScalarWhereInput[] | OrderableProductScalarWhereInput
  >;
  NOT?: Maybe<
    OrderableProductScalarWhereInput[] | OrderableProductScalarWhereInput
  >;
}

export interface ShopCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  zipCode: String;
  city: String;
  phoneNumber: String;
  openingHours: String;
  MOTD?: Maybe<String>;
  products?: Maybe<ProductCreateManyWithoutShopInput>;
  newProducts?: Maybe<OrderableProductCreateManyWithoutShopNewProductInput>;
  bestSellerProducts?: Maybe<
    OrderableProductCreateManyWithoutShopBestSellerInput
  >;
}

export interface OrderableProductUpdateManyWithWhereNestedInput {
  where: OrderableProductScalarWhereInput;
  data: OrderableProductUpdateManyDataInput;
}

export interface ProductCreateWithoutShopInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  name: String;
  description?: Maybe<String>;
  brand: BrandCreateOneInput;
  SKU?: Maybe<String>;
  category: CategoryCreateOneInput;
  options?: Maybe<OptionCreateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueCreateManyInput>;
  variants?: Maybe<VariantCreateManyWithoutProductInput>;
  attributes?: Maybe<AttributeCreateManyWithoutProductsInput>;
  displayPrice: Float;
  available: Boolean;
  imageUrl?: Maybe<String>;
  orderables?: Maybe<OrderableProductCreateManyWithoutProductInput>;
}

export interface OrderableProductUpdateManyDataInput {
  position?: Maybe<Int>;
}

export interface BrandCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  category: CategoryCreateOneInput;
  shop: ShopCreateOneInput;
}

export interface ShopUpsertWithoutProductsInput {
  update: ShopUpdateWithoutProductsDataInput;
  create: ShopCreateWithoutProductsInput;
}

export interface OptionCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  values?: Maybe<OptionValueCreateManyInput>;
  category: CategoryCreateOneWithoutOptionsInput;
  shop: ShopCreateOneInput;
}

export interface ProductUpsertWithoutOrderablesInput {
  update: ProductUpdateWithoutOrderablesDataInput;
  create: ProductCreateWithoutOrderablesInput;
}

export interface CategoryCreateWithoutOptionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  shop: ShopCreateOneInput;
}

export interface OrderableProductUpsertWithWhereUniqueWithoutShopNewProductInput {
  where: OrderableProductWhereUniqueInput;
  update: OrderableProductUpdateWithoutShopNewProductDataInput;
  create: OrderableProductCreateWithoutShopNewProductInput;
}

export interface VariantCreateWithoutProductInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  selectedOptions?: Maybe<SelectedOptionCreateManyWithoutVariantInput>;
  price: Float;
  available: Boolean;
}

export interface ShopUpsertWithoutBestSellerProductsInput {
  update: ShopUpdateWithoutBestSellerProductsDataInput;
  create: ShopCreateWithoutBestSellerProductsInput;
}

export interface SelectedOptionCreateWithoutVariantInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  option: OptionCreateOneInput;
  value: OptionValueCreateOneInput;
}

export interface OrderableProductUpsertWithWhereUniqueWithoutProductInput {
  where: OrderableProductWhereUniqueInput;
  update: OrderableProductUpdateWithoutProductDataInput;
  create: OrderableProductCreateWithoutProductInput;
}

export interface OptionValueCreateOneInput {
  create?: Maybe<OptionValueCreateInput>;
  connect?: Maybe<OptionValueWhereUniqueInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutShopInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutShopDataInput;
  create: ProductCreateWithoutShopInput;
}

export interface AttributeCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  value: String;
  category: CategoryCreateOneInput;
  shop: ShopCreateOneInput;
}

export interface ProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  SKU?: Maybe<String>;
  SKU_not?: Maybe<String>;
  SKU_in?: Maybe<String[] | String>;
  SKU_not_in?: Maybe<String[] | String>;
  SKU_lt?: Maybe<String>;
  SKU_lte?: Maybe<String>;
  SKU_gt?: Maybe<String>;
  SKU_gte?: Maybe<String>;
  SKU_contains?: Maybe<String>;
  SKU_not_contains?: Maybe<String>;
  SKU_starts_with?: Maybe<String>;
  SKU_not_starts_with?: Maybe<String>;
  SKU_ends_with?: Maybe<String>;
  SKU_not_ends_with?: Maybe<String>;
  displayPrice?: Maybe<Float>;
  displayPrice_not?: Maybe<Float>;
  displayPrice_in?: Maybe<Float[] | Float>;
  displayPrice_not_in?: Maybe<Float[] | Float>;
  displayPrice_lt?: Maybe<Float>;
  displayPrice_lte?: Maybe<Float>;
  displayPrice_gt?: Maybe<Float>;
  displayPrice_gte?: Maybe<Float>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export interface OrderableProductCreateWithoutProductInput {
  id?: Maybe<ID_Input>;
  position: Int;
  shopBestSeller?: Maybe<ShopCreateOneWithoutBestSellerProductsInput>;
  shopNewProduct?: Maybe<ShopCreateOneWithoutNewProductsInput>;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ShopCreateWithoutBestSellerProductsInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  zipCode: String;
  city: String;
  phoneNumber: String;
  openingHours: String;
  MOTD?: Maybe<String>;
  products?: Maybe<ProductCreateManyWithoutShopInput>;
  newProducts?: Maybe<OrderableProductCreateManyWithoutShopNewProductInput>;
}

export interface ProductUpdateManyDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  SKU?: Maybe<String>;
  displayPrice?: Maybe<Float>;
  available?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
}

export interface OrderableProductCreateWithoutShopNewProductInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneWithoutOrderablesInput;
  position: Int;
  shopBestSeller?: Maybe<ShopCreateOneWithoutBestSellerProductsInput>;
}

export interface ShopUpsertNestedInput {
  update: ShopUpdateDataInput;
  create: ShopCreateInput;
}

export interface ProductCreateWithoutOrderablesInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  shop: ShopCreateOneWithoutProductsInput;
  name: String;
  description?: Maybe<String>;
  brand: BrandCreateOneInput;
  SKU?: Maybe<String>;
  category: CategoryCreateOneInput;
  options?: Maybe<OptionCreateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueCreateManyInput>;
  variants?: Maybe<VariantCreateManyWithoutProductInput>;
  attributes?: Maybe<AttributeCreateManyWithoutProductsInput>;
  displayPrice: Float;
  available: Boolean;
  imageUrl?: Maybe<String>;
}

export interface OptionUpsertWithWhereUniqueWithoutCategoryInput {
  where: OptionWhereUniqueInput;
  update: OptionUpdateWithoutCategoryDataInput;
  create: OptionCreateWithoutCategoryInput;
}

export interface ShopCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  zipCode: String;
  city: String;
  phoneNumber: String;
  openingHours: String;
  MOTD?: Maybe<String>;
  newProducts?: Maybe<OrderableProductCreateManyWithoutShopNewProductInput>;
  bestSellerProducts?: Maybe<
    OrderableProductCreateManyWithoutShopBestSellerInput
  >;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface OrderableProductCreateWithoutShopBestSellerInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneWithoutOrderablesInput;
  position: Int;
  shopNewProduct?: Maybe<ShopCreateOneWithoutNewProductsInput>;
}

export interface ProductUpdateManyWithoutAttributesInput {
  create?: Maybe<
    ProductCreateWithoutAttributesInput[] | ProductCreateWithoutAttributesInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutAttributesInput[]
    | ProductUpdateWithWhereUniqueWithoutAttributesInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutAttributesInput[]
    | ProductUpsertWithWhereUniqueWithoutAttributesInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ShopCreateWithoutNewProductsInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  zipCode: String;
  city: String;
  phoneNumber: String;
  openingHours: String;
  MOTD?: Maybe<String>;
  products?: Maybe<ProductCreateManyWithoutShopInput>;
  bestSellerProducts?: Maybe<
    OrderableProductCreateManyWithoutShopBestSellerInput
  >;
}

export interface ProductUpdateWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutAttributesDataInput;
}

export interface ProductCreateWithoutAttributesInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  shop: ShopCreateOneWithoutProductsInput;
  name: String;
  description?: Maybe<String>;
  brand: BrandCreateOneInput;
  SKU?: Maybe<String>;
  category: CategoryCreateOneInput;
  options?: Maybe<OptionCreateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueCreateManyInput>;
  variants?: Maybe<VariantCreateManyWithoutProductInput>;
  displayPrice: Float;
  available: Boolean;
  imageUrl?: Maybe<String>;
  orderables?: Maybe<OrderableProductCreateManyWithoutProductInput>;
}

export interface ProductUpdateWithoutAttributesDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  shop?: Maybe<ShopUpdateOneRequiredWithoutProductsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredInput>;
  SKU?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  options?: Maybe<OptionUpdateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueUpdateManyInput>;
  variants?: Maybe<VariantUpdateManyWithoutProductInput>;
  displayPrice?: Maybe<Float>;
  available?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
  orderables?: Maybe<OrderableProductUpdateManyWithoutProductInput>;
}

export interface CategoryUpdateOneRequiredInput {
  create?: Maybe<CategoryCreateInput>;
  update?: Maybe<CategoryUpdateDataInput>;
  upsert?: Maybe<CategoryUpsertNestedInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutAttributesDataInput;
  create: ProductCreateWithoutAttributesInput;
}

export interface OptionUpdateManyWithoutCategoryInput {
  create?: Maybe<
    OptionCreateWithoutCategoryInput[] | OptionCreateWithoutCategoryInput
  >;
  delete?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  connect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  set?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  disconnect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  update?: Maybe<
    | OptionUpdateWithWhereUniqueWithoutCategoryInput[]
    | OptionUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | OptionUpsertWithWhereUniqueWithoutCategoryInput[]
    | OptionUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
  updateMany?: Maybe<
    | OptionUpdateManyWithWhereNestedInput[]
    | OptionUpdateManyWithWhereNestedInput
  >;
}

export interface AttributeUpdateManyMutationInput {
  value?: Maybe<String>;
}

export interface OptionUpdateWithoutCategoryDataInput {
  name?: Maybe<String>;
  values?: Maybe<OptionValueUpdateManyInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface ConversationParticipantCreateWithoutConversationInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutConversationsInput;
  role?: Maybe<ConversationParticipantRole>;
}

export interface OptionValueUpdateWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput;
  data: OptionValueUpdateDataInput;
}

export interface ConversationParticipantCreateManyWithoutConversationInput {
  create?: Maybe<
    | ConversationParticipantCreateWithoutConversationInput[]
    | ConversationParticipantCreateWithoutConversationInput
  >;
  connect?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
}

export interface OptionValueUpsertWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput;
  update: OptionValueUpdateDataInput;
  create: OptionValueCreateInput;
}

export interface BlockListCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  blockedUser: UserCreateOneInput;
}

export interface OptionValueUpdateManyWithWhereNestedInput {
  where: OptionValueScalarWhereInput;
  data: OptionValueUpdateManyDataInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ShopUpdateOneRequiredInput {
  create?: Maybe<ShopCreateInput>;
  update?: Maybe<ShopUpdateDataInput>;
  upsert?: Maybe<ShopUpsertNestedInput>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  selectedShop?: Maybe<ShopCreateOneInput>;
  email: String;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserCreaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  conversations?: Maybe<ConversationParticipantCreateManyWithoutUserInput>;
  contacts?: Maybe<UserCreateManyInput>;
  cart?: Maybe<OrderLineItemCreateManyWithoutOwnerInput>;
  orders?: Maybe<OrderCreateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface ProductUpdateManyWithoutShopInput {
  create?: Maybe<
    ProductCreateWithoutShopInput[] | ProductCreateWithoutShopInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutShopInput[]
    | ProductUpdateWithWhereUniqueWithoutShopInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutShopInput[]
    | ProductUpsertWithWhereUniqueWithoutShopInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreaterolesInput {
  set?: Maybe<UserRole[] | UserRole>;
}

export interface VariantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VariantWhereInput>;
  AND?: Maybe<VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput>;
  OR?: Maybe<VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput>;
  NOT?: Maybe<VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput>;
}

export interface ConversationParticipantCreateManyWithoutUserInput {
  create?: Maybe<
    | ConversationParticipantCreateWithoutUserInput[]
    | ConversationParticipantCreateWithoutUserInput
  >;
  connect?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface ConversationParticipantCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  conversation: ConversationCreateOneWithoutParticipantsInput;
  role?: Maybe<ConversationParticipantRole>;
}

export interface OptionValueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OptionValueWhereInput>;
  AND?: Maybe<
    OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput
  >;
  OR?: Maybe<
    OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput
  >;
}

export interface ConversationCreateOneWithoutParticipantsInput {
  create?: Maybe<ConversationCreateWithoutParticipantsInput>;
  connect?: Maybe<ConversationWhereUniqueInput>;
}

export interface ConversationParticipantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ConversationParticipantWhereInput>;
  AND?: Maybe<
    | ConversationParticipantSubscriptionWhereInput[]
    | ConversationParticipantSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ConversationParticipantSubscriptionWhereInput[]
    | ConversationParticipantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ConversationParticipantSubscriptionWhereInput[]
    | ConversationParticipantSubscriptionWhereInput
  >;
}

export interface ConversationCreateWithoutParticipantsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  creator: UserCreateOneInput;
  conversationType: ConversationType;
  messages?: Maybe<MessageCreateManyWithoutConversationInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  selectedShop?: Maybe<ShopWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  emailVerified_not?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  last_login_date_not?: Maybe<DateTimeInput>;
  last_login_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_login_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_login_date_lt?: Maybe<DateTimeInput>;
  last_login_date_lte?: Maybe<DateTimeInput>;
  last_login_date_gt?: Maybe<DateTimeInput>;
  last_login_date_gte?: Maybe<DateTimeInput>;
  conversations_every?: Maybe<ConversationParticipantWhereInput>;
  conversations_some?: Maybe<ConversationParticipantWhereInput>;
  conversations_none?: Maybe<ConversationParticipantWhereInput>;
  contacts_every?: Maybe<UserWhereInput>;
  contacts_some?: Maybe<UserWhereInput>;
  contacts_none?: Maybe<UserWhereInput>;
  cart_every?: Maybe<OrderLineItemWhereInput>;
  cart_some?: Maybe<OrderLineItemWhereInput>;
  cart_none?: Maybe<OrderLineItemWhereInput>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  stripeCustomerId?: Maybe<String>;
  stripeCustomerId_not?: Maybe<String>;
  stripeCustomerId_in?: Maybe<String[] | String>;
  stripeCustomerId_not_in?: Maybe<String[] | String>;
  stripeCustomerId_lt?: Maybe<String>;
  stripeCustomerId_lte?: Maybe<String>;
  stripeCustomerId_gt?: Maybe<String>;
  stripeCustomerId_gte?: Maybe<String>;
  stripeCustomerId_contains?: Maybe<String>;
  stripeCustomerId_not_contains?: Maybe<String>;
  stripeCustomerId_starts_with?: Maybe<String>;
  stripeCustomerId_not_starts_with?: Maybe<String>;
  stripeCustomerId_ends_with?: Maybe<String>;
  stripeCustomerId_not_ends_with?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
  oneSignalUserId_not?: Maybe<String>;
  oneSignalUserId_in?: Maybe<String[] | String>;
  oneSignalUserId_not_in?: Maybe<String[] | String>;
  oneSignalUserId_lt?: Maybe<String>;
  oneSignalUserId_lte?: Maybe<String>;
  oneSignalUserId_gt?: Maybe<String>;
  oneSignalUserId_gte?: Maybe<String>;
  oneSignalUserId_contains?: Maybe<String>;
  oneSignalUserId_not_contains?: Maybe<String>;
  oneSignalUserId_starts_with?: Maybe<String>;
  oneSignalUserId_not_starts_with?: Maybe<String>;
  oneSignalUserId_ends_with?: Maybe<String>;
  oneSignalUserId_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface MessageCreateManyWithoutConversationInput {
  create?: Maybe<
    | MessageCreateWithoutConversationInput[]
    | MessageCreateWithoutConversationInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface ConversationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  creator?: Maybe<UserWhereInput>;
  participants_every?: Maybe<ConversationParticipantWhereInput>;
  participants_some?: Maybe<ConversationParticipantWhereInput>;
  participants_none?: Maybe<ConversationParticipantWhereInput>;
  conversationType?: Maybe<ConversationType>;
  conversationType_not?: Maybe<ConversationType>;
  conversationType_in?: Maybe<ConversationType[] | ConversationType>;
  conversationType_not_in?: Maybe<ConversationType[] | ConversationType>;
  messages_every?: Maybe<MessageWhereInput>;
  messages_some?: Maybe<MessageWhereInput>;
  messages_none?: Maybe<MessageWhereInput>;
  AND?: Maybe<ConversationWhereInput[] | ConversationWhereInput>;
  OR?: Maybe<ConversationWhereInput[] | ConversationWhereInput>;
  NOT?: Maybe<ConversationWhereInput[] | ConversationWhereInput>;
}

export interface MessageCreateWithoutConversationInput {
  id?: Maybe<ID_Input>;
  sender: UserCreateOneInput;
  messageType?: Maybe<MessageType>;
  message: String;
  attachmentThumbUrl?: Maybe<String>;
  attachmentUrl?: Maybe<String>;
  isDeleted?: Maybe<Boolean>;
}

export interface SelectedOptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  option?: Maybe<OptionWhereInput>;
  variant?: Maybe<VariantWhereInput>;
  value?: Maybe<OptionValueWhereInput>;
  AND?: Maybe<SelectedOptionWhereInput[] | SelectedOptionWhereInput>;
  OR?: Maybe<SelectedOptionWhereInput[] | SelectedOptionWhereInput>;
  NOT?: Maybe<SelectedOptionWhereInput[] | SelectedOptionWhereInput>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface BrandWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<CategoryWhereInput>;
  shop?: Maybe<ShopWhereInput>;
  AND?: Maybe<BrandWhereInput[] | BrandWhereInput>;
  OR?: Maybe<BrandWhereInput[] | BrandWhereInput>;
  NOT?: Maybe<BrandWhereInput[] | BrandWhereInput>;
}

export interface OrderLineItemCreateManyWithoutOwnerInput {
  create?: Maybe<
    | OrderLineItemCreateWithoutOwnerInput[]
    | OrderLineItemCreateWithoutOwnerInput
  >;
  connect?: Maybe<
    OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput
  >;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface OrderLineItemCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  quantity: Int;
  variant?: Maybe<VariantCreateOneInput>;
  shop: ShopCreateOneInput;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  options_every?: Maybe<OptionWhereInput>;
  options_some?: Maybe<OptionWhereInput>;
  options_none?: Maybe<OptionWhereInput>;
  shop?: Maybe<ShopWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface VariantCreateOneInput {
  create?: Maybe<VariantCreateInput>;
  connect?: Maybe<VariantWhereUniqueInput>;
}

export type BrandWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface VariantCreateInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  selectedOptions?: Maybe<SelectedOptionCreateManyWithoutVariantInput>;
  price: Float;
  available: Boolean;
  product?: Maybe<ProductCreateOneWithoutVariantsInput>;
}

export interface VariantUpdateOneRequiredWithoutSelectedOptionsInput {
  create?: Maybe<VariantCreateWithoutSelectedOptionsInput>;
  update?: Maybe<VariantUpdateWithoutSelectedOptionsDataInput>;
  upsert?: Maybe<VariantUpsertWithoutSelectedOptionsInput>;
  connect?: Maybe<VariantWhereUniqueInput>;
}

export interface ProductCreateOneWithoutVariantsInput {
  create?: Maybe<ProductCreateWithoutVariantsInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface VariantCreateWithoutSelectedOptionsInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  price: Float;
  available: Boolean;
  product?: Maybe<ProductCreateOneWithoutVariantsInput>;
}

export interface ProductCreateWithoutVariantsInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  shop: ShopCreateOneWithoutProductsInput;
  name: String;
  description?: Maybe<String>;
  brand: BrandCreateOneInput;
  SKU?: Maybe<String>;
  category: CategoryCreateOneInput;
  options?: Maybe<OptionCreateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueCreateManyInput>;
  attributes?: Maybe<AttributeCreateManyWithoutProductsInput>;
  displayPrice: Float;
  available: Boolean;
  imageUrl?: Maybe<String>;
  orderables?: Maybe<OrderableProductCreateManyWithoutProductInput>;
}

export interface ProductUpdateManyMutationInput {
  deletedAt?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  SKU?: Maybe<String>;
  displayPrice?: Maybe<Float>;
  available?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
}

export interface OrderCreateManyWithoutOwnerInput {
  create?: Maybe<OrderCreateWithoutOwnerInput[] | OrderCreateWithoutOwnerInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface OrderableProductUpdateManyMutationInput {
  position?: Maybe<Int>;
}

export interface OrderCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  receiver: ShopCreateOneInput;
  lineItems?: Maybe<OrderLineItemCreateManyInput>;
  totalPrice: Float;
  totalRefunded: Float;
  totalTax: Float;
  orderStatus: OrderStatus;
}

export interface OrderLineItemUpdateManyMutationInput {
  deletedAt?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
}

export interface OrderLineItemCreateManyInput {
  create?: Maybe<OrderLineItemCreateInput[] | OrderLineItemCreateInput>;
  connect?: Maybe<
    OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput
  >;
}

export interface UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput;
  create: UserCreateWithoutOrdersInput;
}

export interface OrderLineItemCreateInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  quantity: Int;
  variant?: Maybe<VariantCreateOneInput>;
  owner?: Maybe<UserCreateOneWithoutCartInput>;
  shop: ShopCreateOneInput;
}

export interface OrderUpdateInput {
  owner?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  receiver?: Maybe<ShopUpdateOneRequiredInput>;
  lineItems?: Maybe<OrderLineItemUpdateManyInput>;
  totalPrice?: Maybe<Float>;
  totalRefunded?: Maybe<Float>;
  totalTax?: Maybe<Float>;
  orderStatus?: Maybe<OrderStatus>;
}

export interface UserCreateOneWithoutCartInput {
  create?: Maybe<UserCreateWithoutCartInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  owner: UserCreateOneWithoutOrdersInput;
  receiver: ShopCreateOneInput;
  lineItems?: Maybe<OrderLineItemCreateManyInput>;
  totalPrice: Float;
  totalRefunded: Float;
  totalTax: Float;
  orderStatus: OrderStatus;
}

export interface UserCreateWithoutCartInput {
  id?: Maybe<ID_Input>;
  selectedShop?: Maybe<ShopCreateOneInput>;
  email: String;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserCreaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  conversations?: Maybe<ConversationParticipantCreateManyWithoutUserInput>;
  contacts?: Maybe<UserCreateManyInput>;
  orders?: Maybe<OrderCreateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface OptionUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface BlockListUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  blockedUser?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ConversationUpsertWithoutMessagesInput {
  update: ConversationUpdateWithoutMessagesDataInput;
  create: ConversationCreateWithoutMessagesInput;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface MessageUpdateInput {
  conversation?: Maybe<ConversationUpdateOneRequiredWithoutMessagesInput>;
  sender?: Maybe<UserUpdateOneRequiredInput>;
  messageType?: Maybe<MessageType>;
  message?: Maybe<String>;
  attachmentThumbUrl?: Maybe<String>;
  attachmentUrl?: Maybe<String>;
  isDeleted?: Maybe<Boolean>;
}

export interface UserUpdateDataInput {
  selectedShop?: Maybe<ShopUpdateOneInput>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  conversations?: Maybe<ConversationParticipantUpdateManyWithoutUserInput>;
  contacts?: Maybe<UserUpdateManyInput>;
  cart?: Maybe<OrderLineItemUpdateManyWithoutOwnerInput>;
  orders?: Maybe<OrderUpdateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>;
  conversation: ConversationCreateOneWithoutMessagesInput;
  sender: UserCreateOneInput;
  messageType?: Maybe<MessageType>;
  message: String;
  attachmentThumbUrl?: Maybe<String>;
  attachmentUrl?: Maybe<String>;
  isDeleted?: Maybe<Boolean>;
}

export interface ShopUpdateOneInput {
  create?: Maybe<ShopCreateInput>;
  update?: Maybe<ShopUpdateDataInput>;
  upsert?: Maybe<ShopUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export interface ConversationParticipantCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutConversationsInput;
  conversation: ConversationCreateOneWithoutParticipantsInput;
  role?: Maybe<ConversationParticipantRole>;
}

export interface UserUpdaterolesInput {
  set?: Maybe<UserRole[] | UserRole>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ConversationParticipantUpdateManyWithoutUserInput {
  create?: Maybe<
    | ConversationParticipantCreateWithoutUserInput[]
    | ConversationParticipantCreateWithoutUserInput
  >;
  delete?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
  connect?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
  set?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
  update?: Maybe<
    | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    | ConversationParticipantScalarWhereInput[]
    | ConversationParticipantScalarWhereInput
  >;
  updateMany?: Maybe<
    | ConversationParticipantUpdateManyWithWhereNestedInput[]
    | ConversationParticipantUpdateManyWithWhereNestedInput
  >;
}

export type VariantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ConversationParticipantUpdateWithWhereUniqueWithoutUserInput {
  where: ConversationParticipantWhereUniqueInput;
  data: ConversationParticipantUpdateWithoutUserDataInput;
}

export interface OptionCreateManyWithoutCategoryInput {
  create?: Maybe<
    OptionCreateWithoutCategoryInput[] | OptionCreateWithoutCategoryInput
  >;
  connect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
}

export interface ConversationParticipantUpdateWithoutUserDataInput {
  conversation?: Maybe<ConversationUpdateOneRequiredWithoutParticipantsInput>;
  role?: Maybe<ConversationParticipantRole>;
}

export interface ShopCreateOneInput {
  create?: Maybe<ShopCreateInput>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export interface ConversationUpdateOneRequiredWithoutParticipantsInput {
  create?: Maybe<ConversationCreateWithoutParticipantsInput>;
  update?: Maybe<ConversationUpdateWithoutParticipantsDataInput>;
  upsert?: Maybe<ConversationUpsertWithoutParticipantsInput>;
  connect?: Maybe<ConversationWhereUniqueInput>;
}

export interface BrandCreateOneInput {
  create?: Maybe<BrandCreateInput>;
  connect?: Maybe<BrandWhereUniqueInput>;
}

export interface ConversationUpdateWithoutParticipantsDataInput {
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  conversationType?: Maybe<ConversationType>;
  messages?: Maybe<MessageUpdateManyWithoutConversationInput>;
}

export interface CategoryCreateOneWithoutOptionsInput {
  create?: Maybe<CategoryCreateWithoutOptionsInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface MessageUpdateManyWithoutConversationInput {
  create?: Maybe<
    | MessageCreateWithoutConversationInput[]
    | MessageCreateWithoutConversationInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    | MessageUpdateWithWhereUniqueWithoutConversationInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    | MessageUpsertWithWhereUniqueWithoutConversationInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface SelectedOptionCreateManyWithoutVariantInput {
  create?: Maybe<
    | SelectedOptionCreateWithoutVariantInput[]
    | SelectedOptionCreateWithoutVariantInput
  >;
  connect?: Maybe<
    SelectedOptionWhereUniqueInput[] | SelectedOptionWhereUniqueInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutConversationInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutConversationDataInput;
}

export interface AttributeCreateManyWithoutProductsInput {
  create?: Maybe<
    AttributeCreateWithoutProductsInput[] | AttributeCreateWithoutProductsInput
  >;
  connect?: Maybe<AttributeWhereUniqueInput[] | AttributeWhereUniqueInput>;
}

export interface MessageUpdateWithoutConversationDataInput {
  sender?: Maybe<UserUpdateOneRequiredInput>;
  messageType?: Maybe<MessageType>;
  message?: Maybe<String>;
  attachmentThumbUrl?: Maybe<String>;
  attachmentUrl?: Maybe<String>;
  isDeleted?: Maybe<Boolean>;
}

export interface ShopCreateOneWithoutBestSellerProductsInput {
  create?: Maybe<ShopCreateWithoutBestSellerProductsInput>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export interface MessageUpsertWithWhereUniqueWithoutConversationInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutConversationDataInput;
  create: MessageCreateWithoutConversationInput;
}

export interface ProductCreateOneWithoutOrderablesInput {
  create?: Maybe<ProductCreateWithoutOrderablesInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface MessageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  messageType?: Maybe<MessageType>;
  messageType_not?: Maybe<MessageType>;
  messageType_in?: Maybe<MessageType[] | MessageType>;
  messageType_not_in?: Maybe<MessageType[] | MessageType>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  attachmentThumbUrl?: Maybe<String>;
  attachmentThumbUrl_not?: Maybe<String>;
  attachmentThumbUrl_in?: Maybe<String[] | String>;
  attachmentThumbUrl_not_in?: Maybe<String[] | String>;
  attachmentThumbUrl_lt?: Maybe<String>;
  attachmentThumbUrl_lte?: Maybe<String>;
  attachmentThumbUrl_gt?: Maybe<String>;
  attachmentThumbUrl_gte?: Maybe<String>;
  attachmentThumbUrl_contains?: Maybe<String>;
  attachmentThumbUrl_not_contains?: Maybe<String>;
  attachmentThumbUrl_starts_with?: Maybe<String>;
  attachmentThumbUrl_not_starts_with?: Maybe<String>;
  attachmentThumbUrl_ends_with?: Maybe<String>;
  attachmentThumbUrl_not_ends_with?: Maybe<String>;
  attachmentUrl?: Maybe<String>;
  attachmentUrl_not?: Maybe<String>;
  attachmentUrl_in?: Maybe<String[] | String>;
  attachmentUrl_not_in?: Maybe<String[] | String>;
  attachmentUrl_lt?: Maybe<String>;
  attachmentUrl_lte?: Maybe<String>;
  attachmentUrl_gt?: Maybe<String>;
  attachmentUrl_gte?: Maybe<String>;
  attachmentUrl_contains?: Maybe<String>;
  attachmentUrl_not_contains?: Maybe<String>;
  attachmentUrl_starts_with?: Maybe<String>;
  attachmentUrl_not_starts_with?: Maybe<String>;
  attachmentUrl_ends_with?: Maybe<String>;
  attachmentUrl_not_ends_with?: Maybe<String>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
}

export interface OrderableProductCreateManyWithoutShopBestSellerInput {
  create?: Maybe<
    | OrderableProductCreateWithoutShopBestSellerInput[]
    | OrderableProductCreateWithoutShopBestSellerInput
  >;
  connect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface ProductCreateManyWithoutAttributesInput {
  create?: Maybe<
    ProductCreateWithoutAttributesInput[] | ProductCreateWithoutAttributesInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface MessageUpdateManyDataInput {
  messageType?: Maybe<MessageType>;
  message?: Maybe<String>;
  attachmentThumbUrl?: Maybe<String>;
  attachmentUrl?: Maybe<String>;
  isDeleted?: Maybe<Boolean>;
}

export interface CategoryUpdateDataInput {
  name?: Maybe<String>;
  options?: Maybe<OptionUpdateManyWithoutCategoryInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface ConversationUpsertWithoutParticipantsInput {
  update: ConversationUpdateWithoutParticipantsDataInput;
  create: ConversationCreateWithoutParticipantsInput;
}

export interface OptionValueUpdateManyInput {
  create?: Maybe<OptionValueCreateInput[] | OptionValueCreateInput>;
  update?: Maybe<
    | OptionValueUpdateWithWhereUniqueNestedInput[]
    | OptionValueUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | OptionValueUpsertWithWhereUniqueNestedInput[]
    | OptionValueUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput>;
  connect?: Maybe<OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput>;
  set?: Maybe<OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput>;
  disconnect?: Maybe<
    OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput
  >;
  deleteMany?: Maybe<
    OptionValueScalarWhereInput[] | OptionValueScalarWhereInput
  >;
  updateMany?: Maybe<
    | OptionValueUpdateManyWithWhereNestedInput[]
    | OptionValueUpdateManyWithWhereNestedInput
  >;
}

export interface ConversationParticipantUpsertWithWhereUniqueWithoutUserInput {
  where: ConversationParticipantWhereUniqueInput;
  update: ConversationParticipantUpdateWithoutUserDataInput;
  create: ConversationParticipantCreateWithoutUserInput;
}

export interface OptionValueScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<OptionValueScalarWhereInput[] | OptionValueScalarWhereInput>;
  OR?: Maybe<OptionValueScalarWhereInput[] | OptionValueScalarWhereInput>;
  NOT?: Maybe<OptionValueScalarWhereInput[] | OptionValueScalarWhereInput>;
}

export interface ConversationParticipantScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  role?: Maybe<ConversationParticipantRole>;
  role_not?: Maybe<ConversationParticipantRole>;
  role_in?: Maybe<ConversationParticipantRole[] | ConversationParticipantRole>;
  role_not_in?: Maybe<
    ConversationParticipantRole[] | ConversationParticipantRole
  >;
  AND?: Maybe<
    | ConversationParticipantScalarWhereInput[]
    | ConversationParticipantScalarWhereInput
  >;
  OR?: Maybe<
    | ConversationParticipantScalarWhereInput[]
    | ConversationParticipantScalarWhereInput
  >;
  NOT?: Maybe<
    | ConversationParticipantScalarWhereInput[]
    | ConversationParticipantScalarWhereInput
  >;
}

export interface ShopUpdateDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  openingHours?: Maybe<String>;
  MOTD?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutShopInput>;
  newProducts?: Maybe<OrderableProductUpdateManyWithoutShopNewProductInput>;
  bestSellerProducts?: Maybe<
    OrderableProductUpdateManyWithoutShopBestSellerInput
  >;
}

export interface ConversationParticipantUpdateManyWithWhereNestedInput {
  where: ConversationParticipantScalarWhereInput;
  data: ConversationParticipantUpdateManyDataInput;
}

export interface ShopSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShopWhereInput>;
  AND?: Maybe<ShopSubscriptionWhereInput[] | ShopSubscriptionWhereInput>;
  OR?: Maybe<ShopSubscriptionWhereInput[] | ShopSubscriptionWhereInput>;
  NOT?: Maybe<ShopSubscriptionWhereInput[] | ShopSubscriptionWhereInput>;
}

export interface ConversationParticipantUpdateManyDataInput {
  role?: Maybe<ConversationParticipantRole>;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  owner?: Maybe<UserWhereInput>;
  receiver?: Maybe<ShopWhereInput>;
  lineItems_every?: Maybe<OrderLineItemWhereInput>;
  lineItems_some?: Maybe<OrderLineItemWhereInput>;
  lineItems_none?: Maybe<OrderLineItemWhereInput>;
  totalPrice?: Maybe<Float>;
  totalPrice_not?: Maybe<Float>;
  totalPrice_in?: Maybe<Float[] | Float>;
  totalPrice_not_in?: Maybe<Float[] | Float>;
  totalPrice_lt?: Maybe<Float>;
  totalPrice_lte?: Maybe<Float>;
  totalPrice_gt?: Maybe<Float>;
  totalPrice_gte?: Maybe<Float>;
  totalRefunded?: Maybe<Float>;
  totalRefunded_not?: Maybe<Float>;
  totalRefunded_in?: Maybe<Float[] | Float>;
  totalRefunded_not_in?: Maybe<Float[] | Float>;
  totalRefunded_lt?: Maybe<Float>;
  totalRefunded_lte?: Maybe<Float>;
  totalRefunded_gt?: Maybe<Float>;
  totalRefunded_gte?: Maybe<Float>;
  totalTax?: Maybe<Float>;
  totalTax_not?: Maybe<Float>;
  totalTax_in?: Maybe<Float[] | Float>;
  totalTax_not_in?: Maybe<Float[] | Float>;
  totalTax_lt?: Maybe<Float>;
  totalTax_lte?: Maybe<Float>;
  totalTax_gt?: Maybe<Float>;
  totalTax_gte?: Maybe<Float>;
  orderStatus?: Maybe<OrderStatus>;
  orderStatus_not?: Maybe<OrderStatus>;
  orderStatus_in?: Maybe<OrderStatus[] | OrderStatus>;
  orderStatus_not_in?: Maybe<OrderStatus[] | OrderStatus>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface BlockListSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BlockListWhereInput>;
  AND?: Maybe<
    BlockListSubscriptionWhereInput[] | BlockListSubscriptionWhereInput
  >;
  OR?: Maybe<
    BlockListSubscriptionWhereInput[] | BlockListSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BlockListSubscriptionWhereInput[] | BlockListSubscriptionWhereInput
  >;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserUpdateInput {
  selectedShop?: Maybe<ShopUpdateOneInput>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  conversations?: Maybe<ConversationParticipantUpdateManyWithoutUserInput>;
  contacts?: Maybe<UserUpdateManyInput>;
  cart?: Maybe<OrderLineItemUpdateManyWithoutOwnerInput>;
  orders?: Maybe<OrderUpdateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  emailVerified_not?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  last_login_date_not?: Maybe<DateTimeInput>;
  last_login_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_login_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_login_date_lt?: Maybe<DateTimeInput>;
  last_login_date_lte?: Maybe<DateTimeInput>;
  last_login_date_gt?: Maybe<DateTimeInput>;
  last_login_date_gte?: Maybe<DateTimeInput>;
  stripeCustomerId?: Maybe<String>;
  stripeCustomerId_not?: Maybe<String>;
  stripeCustomerId_in?: Maybe<String[] | String>;
  stripeCustomerId_not_in?: Maybe<String[] | String>;
  stripeCustomerId_lt?: Maybe<String>;
  stripeCustomerId_lte?: Maybe<String>;
  stripeCustomerId_gt?: Maybe<String>;
  stripeCustomerId_gte?: Maybe<String>;
  stripeCustomerId_contains?: Maybe<String>;
  stripeCustomerId_not_contains?: Maybe<String>;
  stripeCustomerId_starts_with?: Maybe<String>;
  stripeCustomerId_not_starts_with?: Maybe<String>;
  stripeCustomerId_ends_with?: Maybe<String>;
  stripeCustomerId_not_ends_with?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
  oneSignalUserId_not?: Maybe<String>;
  oneSignalUserId_in?: Maybe<String[] | String>;
  oneSignalUserId_not_in?: Maybe<String[] | String>;
  oneSignalUserId_lt?: Maybe<String>;
  oneSignalUserId_lte?: Maybe<String>;
  oneSignalUserId_gt?: Maybe<String>;
  oneSignalUserId_gte?: Maybe<String>;
  oneSignalUserId_contains?: Maybe<String>;
  oneSignalUserId_not_contains?: Maybe<String>;
  oneSignalUserId_starts_with?: Maybe<String>;
  oneSignalUserId_not_starts_with?: Maybe<String>;
  oneSignalUserId_ends_with?: Maybe<String>;
  oneSignalUserId_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface VariantUpsertWithoutSelectedOptionsInput {
  update: VariantUpdateWithoutSelectedOptionsDataInput;
  create: VariantCreateWithoutSelectedOptionsInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export type ConversationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface OrderableProductCreateInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneWithoutOrderablesInput;
  position: Int;
  shopBestSeller?: Maybe<ShopCreateOneWithoutBestSellerProductsInput>;
  shopNewProduct?: Maybe<ShopCreateOneWithoutNewProductsInput>;
}

export interface OrderLineItemUpdateManyWithoutOwnerInput {
  create?: Maybe<
    | OrderLineItemCreateWithoutOwnerInput[]
    | OrderLineItemCreateWithoutOwnerInput
  >;
  delete?: Maybe<
    OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput
  >;
  connect?: Maybe<
    OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput
  >;
  set?: Maybe<OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput>;
  disconnect?: Maybe<
    OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput
  >;
  update?: Maybe<
    | OrderLineItemUpdateWithWhereUniqueWithoutOwnerInput[]
    | OrderLineItemUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | OrderLineItemUpsertWithWhereUniqueWithoutOwnerInput[]
    | OrderLineItemUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<
    OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | OrderLineItemUpdateManyWithWhereNestedInput[]
    | OrderLineItemUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneRequiredWithoutOrdersInput {
  create?: Maybe<UserCreateWithoutOrdersInput>;
  update?: Maybe<UserUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<UserUpsertWithoutOrdersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface OrderLineItemUpdateWithWhereUniqueWithoutOwnerInput {
  where: OrderLineItemWhereUniqueInput;
  data: OrderLineItemUpdateWithoutOwnerDataInput;
}

export interface OptionValueUpdateInput {
  name?: Maybe<String>;
}

export interface OrderLineItemUpdateWithoutOwnerDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  variant?: Maybe<VariantUpdateOneInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface ConversationUpdateOneRequiredWithoutMessagesInput {
  create?: Maybe<ConversationCreateWithoutMessagesInput>;
  update?: Maybe<ConversationUpdateWithoutMessagesDataInput>;
  upsert?: Maybe<ConversationUpsertWithoutMessagesInput>;
  connect?: Maybe<ConversationWhereUniqueInput>;
}

export interface VariantUpdateOneInput {
  create?: Maybe<VariantCreateInput>;
  update?: Maybe<VariantUpdateDataInput>;
  upsert?: Maybe<VariantUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VariantWhereUniqueInput>;
}

export interface ConversationParticipantUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutConversationsInput>;
  conversation?: Maybe<ConversationUpdateOneRequiredWithoutParticipantsInput>;
  role?: Maybe<ConversationParticipantRole>;
}

export interface VariantUpdateDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  selectedOptions?: Maybe<SelectedOptionUpdateManyWithoutVariantInput>;
  price?: Maybe<Float>;
  available?: Maybe<Boolean>;
  product?: Maybe<ProductUpdateOneWithoutVariantsInput>;
}

export interface UserUpdateOneRequiredWithoutConversationsInput {
  create?: Maybe<UserCreateWithoutConversationsInput>;
  update?: Maybe<UserUpdateWithoutConversationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutConversationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ProductUpdateOneWithoutVariantsInput {
  create?: Maybe<ProductCreateWithoutVariantsInput>;
  update?: Maybe<ProductUpdateWithoutVariantsDataInput>;
  upsert?: Maybe<ProductUpsertWithoutVariantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface CategoryCreateOneInput {
  create?: Maybe<CategoryCreateInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface ProductUpdateWithoutVariantsDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  shop?: Maybe<ShopUpdateOneRequiredWithoutProductsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredInput>;
  SKU?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  options?: Maybe<OptionUpdateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueUpdateManyInput>;
  attributes?: Maybe<AttributeUpdateManyWithoutProductsInput>;
  displayPrice?: Maybe<Float>;
  available?: Maybe<Boolean>;
  imageUrl?: Maybe<String>;
  orderables?: Maybe<OrderableProductUpdateManyWithoutProductInput>;
}

export interface ProductCreateManyWithoutShopInput {
  create?: Maybe<
    ProductCreateWithoutShopInput[] | ProductCreateWithoutShopInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductUpsertWithoutVariantsInput {
  update: ProductUpdateWithoutVariantsDataInput;
  create: ProductCreateWithoutVariantsInput;
}

export interface VariantCreateManyWithoutProductInput {
  create?: Maybe<
    VariantCreateWithoutProductInput[] | VariantCreateWithoutProductInput
  >;
  connect?: Maybe<VariantWhereUniqueInput[] | VariantWhereUniqueInput>;
}

export interface VariantUpsertNestedInput {
  update: VariantUpdateDataInput;
  create: VariantCreateInput;
}

export interface OrderableProductCreateManyWithoutProductInput {
  create?: Maybe<
    | OrderableProductCreateWithoutProductInput[]
    | OrderableProductCreateWithoutProductInput
  >;
  connect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
}

export interface OrderLineItemUpsertWithWhereUniqueWithoutOwnerInput {
  where: OrderLineItemWhereUniqueInput;
  update: OrderLineItemUpdateWithoutOwnerDataInput;
  create: OrderLineItemCreateWithoutOwnerInput;
}

export interface ShopCreateOneWithoutProductsInput {
  create?: Maybe<ShopCreateWithoutProductsInput>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export interface OrderLineItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  deletedAt_not?: Maybe<DateTimeInput>;
  deletedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deletedAt_lt?: Maybe<DateTimeInput>;
  deletedAt_lte?: Maybe<DateTimeInput>;
  deletedAt_gt?: Maybe<DateTimeInput>;
  deletedAt_gte?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput>;
  OR?: Maybe<OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput>;
  NOT?: Maybe<OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput>;
}

export interface AttributeUpdateInput {
  value?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
  products?: Maybe<ProductUpdateManyWithoutAttributesInput>;
}

export interface OrderLineItemUpdateManyWithWhereNestedInput {
  where: OrderLineItemScalarWhereInput;
  data: OrderLineItemUpdateManyDataInput;
}

export interface OptionValueUpdateDataInput {
  name?: Maybe<String>;
}

export interface OrderLineItemUpdateManyDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
}

export interface ProductUpdateWithWhereUniqueWithoutShopInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutShopDataInput;
}

export interface OrderUpdateManyWithoutOwnerInput {
  create?: Maybe<OrderCreateWithoutOwnerInput[] | OrderCreateWithoutOwnerInput>;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutOwnerInput[]
    | OrderUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutOwnerInput[]
    | OrderUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderableProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  product?: Maybe<ProductWhereInput>;
  position?: Maybe<Int>;
  position_not?: Maybe<Int>;
  position_in?: Maybe<Int[] | Int>;
  position_not_in?: Maybe<Int[] | Int>;
  position_lt?: Maybe<Int>;
  position_lte?: Maybe<Int>;
  position_gt?: Maybe<Int>;
  position_gte?: Maybe<Int>;
  shopBestSeller?: Maybe<ShopWhereInput>;
  shopNewProduct?: Maybe<ShopWhereInput>;
  AND?: Maybe<OrderableProductWhereInput[] | OrderableProductWhereInput>;
  OR?: Maybe<OrderableProductWhereInput[] | OrderableProductWhereInput>;
  NOT?: Maybe<OrderableProductWhereInput[] | OrderableProductWhereInput>;
}

export interface OrderUpdateWithWhereUniqueWithoutOwnerInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutOwnerDataInput;
}

export interface VariantUpdateInput {
  deletedAt?: Maybe<DateTimeInput>;
  selectedOptions?: Maybe<SelectedOptionUpdateManyWithoutVariantInput>;
  price?: Maybe<Float>;
  available?: Maybe<Boolean>;
  product?: Maybe<ProductUpdateOneWithoutVariantsInput>;
}

export interface OrderUpdateWithoutOwnerDataInput {
  receiver?: Maybe<ShopUpdateOneRequiredInput>;
  lineItems?: Maybe<OrderLineItemUpdateManyInput>;
  totalPrice?: Maybe<Float>;
  totalRefunded?: Maybe<Float>;
  totalTax?: Maybe<Float>;
  orderStatus?: Maybe<OrderStatus>;
}

export interface OptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  values_every?: Maybe<OptionValueWhereInput>;
  values_some?: Maybe<OptionValueWhereInput>;
  values_none?: Maybe<OptionValueWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  shop?: Maybe<ShopWhereInput>;
  AND?: Maybe<OptionWhereInput[] | OptionWhereInput>;
  OR?: Maybe<OptionWhereInput[] | OptionWhereInput>;
  NOT?: Maybe<OptionWhereInput[] | OptionWhereInput>;
}

export interface OrderLineItemUpdateManyInput {
  create?: Maybe<OrderLineItemCreateInput[] | OrderLineItemCreateInput>;
  update?: Maybe<
    | OrderLineItemUpdateWithWhereUniqueNestedInput[]
    | OrderLineItemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | OrderLineItemUpsertWithWhereUniqueNestedInput[]
    | OrderLineItemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput
  >;
  connect?: Maybe<
    OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput
  >;
  set?: Maybe<OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput>;
  disconnect?: Maybe<
    OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput
  >;
  deleteMany?: Maybe<
    OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | OrderLineItemUpdateManyWithWhereNestedInput[]
    | OrderLineItemUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateManyMutationInput {
  totalPrice?: Maybe<Float>;
  totalRefunded?: Maybe<Float>;
  totalTax?: Maybe<Float>;
  orderStatus?: Maybe<OrderStatus>;
}

export interface OrderLineItemUpdateWithWhereUniqueNestedInput {
  where: OrderLineItemWhereUniqueInput;
  data: OrderLineItemUpdateDataInput;
}

export interface MessageUpdateManyMutationInput {
  messageType?: Maybe<MessageType>;
  message?: Maybe<String>;
  attachmentThumbUrl?: Maybe<String>;
  attachmentUrl?: Maybe<String>;
  isDeleted?: Maybe<Boolean>;
}

export interface OrderLineItemUpdateDataInput {
  deletedAt?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  variant?: Maybe<VariantUpdateOneInput>;
  owner?: Maybe<UserUpdateOneWithoutCartInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput {
  where: ConversationParticipantWhereUniqueInput;
  update: ConversationParticipantUpdateWithoutConversationDataInput;
  create: ConversationParticipantCreateWithoutConversationInput;
}

export interface UserUpdateOneWithoutCartInput {
  create?: Maybe<UserCreateWithoutCartInput>;
  update?: Maybe<UserUpdateWithoutCartDataInput>;
  upsert?: Maybe<UserUpsertWithoutCartInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface OptionValueCreateManyInput {
  create?: Maybe<OptionValueCreateInput[] | OptionValueCreateInput>;
  connect?: Maybe<OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput>;
}

export interface UserUpdateWithoutCartDataInput {
  selectedShop?: Maybe<ShopUpdateOneInput>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  avatar?: Maybe<String>;
  last_login_date?: Maybe<DateTimeInput>;
  conversations?: Maybe<ConversationParticipantUpdateManyWithoutUserInput>;
  contacts?: Maybe<UserUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutOwnerInput>;
  stripeCustomerId?: Maybe<String>;
  oneSignalUserId?: Maybe<String>;
}

export interface OptionCreateOneInput {
  create?: Maybe<OptionCreateInput>;
  connect?: Maybe<OptionWhereUniqueInput>;
}

export interface UserUpsertWithoutCartInput {
  update: UserUpdateWithoutCartDataInput;
  create: UserCreateWithoutCartInput;
}

export interface ShopCreateOneWithoutNewProductsInput {
  create?: Maybe<ShopCreateWithoutNewProductsInput>;
  connect?: Maybe<ShopWhereUniqueInput>;
}

export interface OrderLineItemUpsertWithWhereUniqueNestedInput {
  where: OrderLineItemWhereUniqueInput;
  update: OrderLineItemUpdateDataInput;
  create: OrderLineItemCreateInput;
}

export interface OptionValueUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface OrderUpsertWithWhereUniqueWithoutOwnerInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutOwnerDataInput;
  create: OrderCreateWithoutOwnerInput;
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  conversation?: Maybe<ConversationWhereInput>;
  sender?: Maybe<UserWhereInput>;
  messageType?: Maybe<MessageType>;
  messageType_not?: Maybe<MessageType>;
  messageType_in?: Maybe<MessageType[] | MessageType>;
  messageType_not_in?: Maybe<MessageType[] | MessageType>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  attachmentThumbUrl?: Maybe<String>;
  attachmentThumbUrl_not?: Maybe<String>;
  attachmentThumbUrl_in?: Maybe<String[] | String>;
  attachmentThumbUrl_not_in?: Maybe<String[] | String>;
  attachmentThumbUrl_lt?: Maybe<String>;
  attachmentThumbUrl_lte?: Maybe<String>;
  attachmentThumbUrl_gt?: Maybe<String>;
  attachmentThumbUrl_gte?: Maybe<String>;
  attachmentThumbUrl_contains?: Maybe<String>;
  attachmentThumbUrl_not_contains?: Maybe<String>;
  attachmentThumbUrl_starts_with?: Maybe<String>;
  attachmentThumbUrl_not_starts_with?: Maybe<String>;
  attachmentThumbUrl_ends_with?: Maybe<String>;
  attachmentThumbUrl_not_ends_with?: Maybe<String>;
  attachmentUrl?: Maybe<String>;
  attachmentUrl_not?: Maybe<String>;
  attachmentUrl_in?: Maybe<String[] | String>;
  attachmentUrl_not_in?: Maybe<String[] | String>;
  attachmentUrl_lt?: Maybe<String>;
  attachmentUrl_lte?: Maybe<String>;
  attachmentUrl_gt?: Maybe<String>;
  attachmentUrl_gte?: Maybe<String>;
  attachmentUrl_contains?: Maybe<String>;
  attachmentUrl_not_contains?: Maybe<String>;
  attachmentUrl_starts_with?: Maybe<String>;
  attachmentUrl_not_starts_with?: Maybe<String>;
  attachmentUrl_ends_with?: Maybe<String>;
  attachmentUrl_not_ends_with?: Maybe<String>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  OR?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export interface OrderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  totalPrice?: Maybe<Float>;
  totalPrice_not?: Maybe<Float>;
  totalPrice_in?: Maybe<Float[] | Float>;
  totalPrice_not_in?: Maybe<Float[] | Float>;
  totalPrice_lt?: Maybe<Float>;
  totalPrice_lte?: Maybe<Float>;
  totalPrice_gt?: Maybe<Float>;
  totalPrice_gte?: Maybe<Float>;
  totalRefunded?: Maybe<Float>;
  totalRefunded_not?: Maybe<Float>;
  totalRefunded_in?: Maybe<Float[] | Float>;
  totalRefunded_not_in?: Maybe<Float[] | Float>;
  totalRefunded_lt?: Maybe<Float>;
  totalRefunded_lte?: Maybe<Float>;
  totalRefunded_gt?: Maybe<Float>;
  totalRefunded_gte?: Maybe<Float>;
  totalTax?: Maybe<Float>;
  totalTax_not?: Maybe<Float>;
  totalTax_in?: Maybe<Float[] | Float>;
  totalTax_not_in?: Maybe<Float[] | Float>;
  totalTax_lt?: Maybe<Float>;
  totalTax_lte?: Maybe<Float>;
  totalTax_gt?: Maybe<Float>;
  totalTax_gte?: Maybe<Float>;
  orderStatus?: Maybe<OrderStatus>;
  orderStatus_not?: Maybe<OrderStatus>;
  orderStatus_in?: Maybe<OrderStatus[] | OrderStatus>;
  orderStatus_not_in?: Maybe<OrderStatus[] | OrderStatus>;
  AND?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  OR?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  NOT?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  deletedAt?: Maybe<DateTimeInput>;
  shop: ShopCreateOneWithoutProductsInput;
  name: String;
  description?: Maybe<String>;
  brand: BrandCreateOneInput;
  SKU?: Maybe<String>;
  category: CategoryCreateOneInput;
  options?: Maybe<OptionCreateManyInput>;
  unavailableOptionsValues?: Maybe<OptionValueCreateManyInput>;
  variants?: Maybe<VariantCreateManyWithoutProductInput>;
  attributes?: Maybe<AttributeCreateManyWithoutProductsInput>;
  displayPrice: Float;
  available: Boolean;
  imageUrl?: Maybe<String>;
  orderables?: Maybe<OrderableProductCreateManyWithoutProductInput>;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface ConversationCreateOneWithoutMessagesInput {
  create?: Maybe<ConversationCreateWithoutMessagesInput>;
  connect?: Maybe<ConversationWhereUniqueInput>;
}

export interface OrderUpdateManyDataInput {
  totalPrice?: Maybe<Float>;
  totalRefunded?: Maybe<Float>;
  totalTax?: Maybe<Float>;
  orderStatus?: Maybe<OrderStatus>;
}

export interface OptionCreateManyInput {
  create?: Maybe<OptionCreateInput[] | OptionCreateInput>;
  connect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface OptionUpdateWithWhereUniqueWithoutCategoryInput {
  where: OptionWhereUniqueInput;
  data: OptionUpdateWithoutCategoryDataInput;
}

export interface CategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CategoryUpdateInput {
  name?: Maybe<String>;
  options?: Maybe<OptionUpdateManyWithoutCategoryInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface BrandUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface BrandUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  shop?: Maybe<ShopUpdateOneRequiredInput>;
}

export interface OrderLineItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderLineItemWhereInput>;
  AND?: Maybe<
    OrderLineItemSubscriptionWhereInput[] | OrderLineItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    OrderLineItemSubscriptionWhereInput[] | OrderLineItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OrderLineItemSubscriptionWhereInput[] | OrderLineItemSubscriptionWhereInput
  >;
}

export interface OrderableProductCreateManyWithoutShopNewProductInput {
  create?: Maybe<
    | OrderableProductCreateWithoutShopNewProductInput[]
    | OrderableProductCreateWithoutShopNewProductInput
  >;
  connect?: Maybe<
    OrderableProductWhereUniqueInput[] | OrderableProductWhereUniqueInput
  >;
}

export interface ConversationParticipantUpdateManyWithoutConversationInput {
  create?: Maybe<
    | ConversationParticipantCreateWithoutConversationInput[]
    | ConversationParticipantCreateWithoutConversationInput
  >;
  delete?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
  connect?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
  set?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ConversationParticipantWhereUniqueInput[]
    | ConversationParticipantWhereUniqueInput
  >;
  update?: Maybe<
    | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput
  >;
  upsert?: Maybe<
    | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput
  >;
  deleteMany?: Maybe<
    | ConversationParticipantScalarWhereInput[]
    | ConversationParticipantScalarWhereInput
  >;
  updateMany?: Maybe<
    | ConversationParticipantUpdateManyWithWhereNestedInput[]
    | ConversationParticipantUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateOneWithoutOrdersInput {
  create?: Maybe<UserCreateWithoutOrdersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ShopUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  openingHours?: Maybe<String>;
  MOTD?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutShopInput>;
  newProducts?: Maybe<OrderableProductUpdateManyWithoutShopNewProductInput>;
  bestSellerProducts?: Maybe<
    OrderableProductUpdateManyWithoutShopBestSellerInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VariantPreviousValues {
  id: ID_Output;
  deletedAt?: DateTimeOutput;
  price: Float;
  available: Boolean;
}

export interface VariantPreviousValuesPromise
  extends Promise<VariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
  price: () => Promise<Float>;
  available: () => Promise<Boolean>;
}

export interface VariantPreviousValuesSubscription
  extends Promise<AsyncIterator<VariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  price: () => Promise<AsyncIterator<Float>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface OrderLineItem {
  id: ID_Output;
  deletedAt?: DateTimeOutput;
  quantity: Int;
}

export interface OrderLineItemPromise
  extends Promise<OrderLineItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
  variant: <T = VariantPromise>() => T;
  owner: <T = UserPromise>() => T;
  shop: <T = ShopPromise>() => T;
}

export interface OrderLineItemSubscription
  extends Promise<AsyncIterator<OrderLineItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  variant: <T = VariantSubscription>() => T;
  owner: <T = UserSubscription>() => T;
  shop: <T = ShopSubscription>() => T;
}

export interface OrderLineItemNullablePromise
  extends Promise<OrderLineItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
  variant: <T = VariantPromise>() => T;
  owner: <T = UserPromise>() => T;
  shop: <T = ShopPromise>() => T;
}

export interface Product {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  name: String;
  description?: String;
  SKU?: String;
  displayPrice: Float;
  available: Boolean;
  imageUrl?: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  shop: <T = ShopPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  brand: <T = BrandPromise>() => T;
  SKU: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  options: <T = FragmentableArray<Option>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  unavailableOptionsValues: <T = FragmentableArray<OptionValue>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  variants: <T = FragmentableArray<Variant>>(args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  attributes: <T = FragmentableArray<Attribute>>(args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  displayPrice: () => Promise<Float>;
  available: () => Promise<Boolean>;
  imageUrl: () => Promise<String>;
  orderables: <T = FragmentableArray<OrderableProduct>>(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  shop: <T = ShopSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  brand: <T = BrandSubscription>() => T;
  SKU: () => Promise<AsyncIterator<String>>;
  category: <T = CategorySubscription>() => T;
  options: <T = Promise<AsyncIterator<OptionSubscription>>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  unavailableOptionsValues: <
    T = Promise<AsyncIterator<OptionValueSubscription>>
  >(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  variants: <T = Promise<AsyncIterator<VariantSubscription>>>(args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  attributes: <T = Promise<AsyncIterator<AttributeSubscription>>>(args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  displayPrice: () => Promise<AsyncIterator<Float>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  orderables: <
    T = Promise<AsyncIterator<OrderableProductSubscription>>
  >(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  shop: <T = ShopPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  brand: <T = BrandPromise>() => T;
  SKU: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  options: <T = FragmentableArray<Option>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  unavailableOptionsValues: <T = FragmentableArray<OptionValue>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  variants: <T = FragmentableArray<Variant>>(args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  attributes: <T = FragmentableArray<Attribute>>(args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  displayPrice: () => Promise<Float>;
  available: () => Promise<Boolean>;
  imageUrl: () => Promise<String>;
  orderables: <T = FragmentableArray<OrderableProduct>>(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BlockListConnection {
  pageInfo: PageInfo;
  edges: BlockListEdge[];
}

export interface BlockListConnectionPromise
  extends Promise<BlockListConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlockListEdge>>() => T;
  aggregate: <T = AggregateBlockListPromise>() => T;
}

export interface BlockListConnectionSubscription
  extends Promise<AsyncIterator<BlockListConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlockListEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlockListSubscription>() => T;
}

export interface ShopPreviousValues {
  id: ID_Output;
  name: String;
  address: String;
  zipCode: String;
  city: String;
  phoneNumber: String;
  openingHours: String;
  MOTD?: String;
}

export interface ShopPreviousValuesPromise
  extends Promise<ShopPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  zipCode: () => Promise<String>;
  city: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  openingHours: () => Promise<String>;
  MOTD: () => Promise<String>;
}

export interface ShopPreviousValuesSubscription
  extends Promise<AsyncIterator<ShopPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  openingHours: () => Promise<AsyncIterator<String>>;
  MOTD: () => Promise<AsyncIterator<String>>;
}

export interface Order {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  totalPrice: Float;
  totalRefunded: Float;
  totalTax: Float;
  orderStatus: OrderStatus;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  receiver: <T = ShopPromise>() => T;
  lineItems: <T = FragmentableArray<OrderLineItem>>(args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  totalPrice: () => Promise<Float>;
  totalRefunded: () => Promise<Float>;
  totalTax: () => Promise<Float>;
  orderStatus: () => Promise<OrderStatus>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
  receiver: <T = ShopSubscription>() => T;
  lineItems: <T = Promise<AsyncIterator<OrderLineItemSubscription>>>(args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  totalPrice: () => Promise<AsyncIterator<Float>>;
  totalRefunded: () => Promise<AsyncIterator<Float>>;
  totalTax: () => Promise<AsyncIterator<Float>>;
  orderStatus: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  receiver: <T = ShopPromise>() => T;
  lineItems: <T = FragmentableArray<OrderLineItem>>(args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  totalPrice: () => Promise<Float>;
  totalRefunded: () => Promise<Float>;
  totalTax: () => Promise<Float>;
  orderStatus: () => Promise<OrderStatus>;
}

export interface Brand {
  id: ID_Output;
  name: String;
}

export interface BrandPromise extends Promise<Brand>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  shop: <T = ShopPromise>() => T;
}

export interface BrandSubscription
  extends Promise<AsyncIterator<Brand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: <T = CategorySubscription>() => T;
  shop: <T = ShopSubscription>() => T;
}

export interface BrandNullablePromise
  extends Promise<Brand | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  shop: <T = ShopPromise>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface VariantEdge {
  node: Variant;
  cursor: String;
}

export interface VariantEdgePromise extends Promise<VariantEdge>, Fragmentable {
  node: <T = VariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VariantEdgeSubscription
  extends Promise<AsyncIterator<VariantEdge>>,
    Fragmentable {
  node: <T = VariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Shop {
  id: ID_Output;
  name: String;
  address: String;
  zipCode: String;
  city: String;
  phoneNumber: String;
  openingHours: String;
  MOTD?: String;
}

export interface ShopPromise extends Promise<Shop>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  zipCode: () => Promise<String>;
  city: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  openingHours: () => Promise<String>;
  MOTD: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newProducts: <T = FragmentableArray<OrderableProduct>>(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bestSellerProducts: <T = FragmentableArray<OrderableProduct>>(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ShopSubscription
  extends Promise<AsyncIterator<Shop>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  openingHours: () => Promise<AsyncIterator<String>>;
  MOTD: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newProducts: <
    T = Promise<AsyncIterator<OrderableProductSubscription>>
  >(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bestSellerProducts: <
    T = Promise<AsyncIterator<OrderableProductSubscription>>
  >(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ShopNullablePromise
  extends Promise<Shop | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  zipCode: () => Promise<String>;
  city: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  openingHours: () => Promise<String>;
  MOTD: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newProducts: <T = FragmentableArray<OrderableProduct>>(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bestSellerProducts: <T = FragmentableArray<OrderableProduct>>(args?: {
    where?: OrderableProductWhereInput;
    orderBy?: OrderableProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Message {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  messageType: MessageType;
  message: String;
  attachmentThumbUrl?: String;
  attachmentUrl?: String;
  isDeleted: Boolean;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  conversation: <T = ConversationPromise>() => T;
  sender: <T = UserPromise>() => T;
  messageType: () => Promise<MessageType>;
  message: () => Promise<String>;
  attachmentThumbUrl: () => Promise<String>;
  attachmentUrl: () => Promise<String>;
  isDeleted: () => Promise<Boolean>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  conversation: <T = ConversationSubscription>() => T;
  sender: <T = UserSubscription>() => T;
  messageType: () => Promise<AsyncIterator<MessageType>>;
  message: () => Promise<AsyncIterator<String>>;
  attachmentThumbUrl: () => Promise<AsyncIterator<String>>;
  attachmentUrl: () => Promise<AsyncIterator<String>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  conversation: <T = ConversationPromise>() => T;
  sender: <T = UserPromise>() => T;
  messageType: () => Promise<MessageType>;
  message: () => Promise<String>;
  attachmentThumbUrl: () => Promise<String>;
  attachmentUrl: () => Promise<String>;
  isDeleted: () => Promise<Boolean>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Conversation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  conversationType: ConversationType;
}

export interface ConversationPromise
  extends Promise<Conversation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  creator: <T = UserPromise>() => T;
  participants: <T = FragmentableArray<ConversationParticipant>>(args?: {
    where?: ConversationParticipantWhereInput;
    orderBy?: ConversationParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversationType: () => Promise<ConversationType>;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ConversationSubscription
  extends Promise<AsyncIterator<Conversation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  creator: <T = UserSubscription>() => T;
  participants: <
    T = Promise<AsyncIterator<ConversationParticipantSubscription>>
  >(args?: {
    where?: ConversationParticipantWhereInput;
    orderBy?: ConversationParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversationType: () => Promise<AsyncIterator<ConversationType>>;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ConversationNullablePromise
  extends Promise<Conversation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  creator: <T = UserPromise>() => T;
  participants: <T = FragmentableArray<ConversationParticipant>>(args?: {
    where?: ConversationParticipantWhereInput;
    orderBy?: ConversationParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conversationType: () => Promise<ConversationType>;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ShopEdge {
  node: Shop;
  cursor: String;
}

export interface ShopEdgePromise extends Promise<ShopEdge>, Fragmentable {
  node: <T = ShopPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShopEdgeSubscription
  extends Promise<AsyncIterator<ShopEdge>>,
    Fragmentable {
  node: <T = ShopSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Attribute {
  id: ID_Output;
  value: String;
}

export interface AttributePromise extends Promise<Attribute>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  shop: <T = ShopPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AttributeSubscription
  extends Promise<AsyncIterator<Attribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  category: <T = CategorySubscription>() => T;
  shop: <T = ShopSubscription>() => T;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AttributeNullablePromise
  extends Promise<Attribute | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  shop: <T = ShopPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VariantSubscriptionPayload {
  mutation: MutationType;
  node: Variant;
  updatedFields: String[];
  previousValues: VariantPreviousValues;
}

export interface VariantSubscriptionPayloadPromise
  extends Promise<VariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VariantPreviousValuesPromise>() => T;
}

export interface VariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VariantPreviousValuesSubscription>() => T;
}

export interface AttributeSubscriptionPayload {
  mutation: MutationType;
  node: Attribute;
  updatedFields: String[];
  previousValues: AttributePreviousValues;
}

export interface AttributeSubscriptionPayloadPromise
  extends Promise<AttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttributePreviousValuesPromise>() => T;
}

export interface AttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttributePreviousValuesSubscription>() => T;
}

export interface SelectedOptionEdge {
  node: SelectedOption;
  cursor: String;
}

export interface SelectedOptionEdgePromise
  extends Promise<SelectedOptionEdge>,
    Fragmentable {
  node: <T = SelectedOptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SelectedOptionEdgeSubscription
  extends Promise<AsyncIterator<SelectedOptionEdge>>,
    Fragmentable {
  node: <T = SelectedOptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AttributePreviousValues {
  id: ID_Output;
  value: String;
}

export interface AttributePreviousValuesPromise
  extends Promise<AttributePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
}

export interface AttributePreviousValuesSubscription
  extends Promise<AsyncIterator<AttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ConversationParticipant {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  role: ConversationParticipantRole;
}

export interface ConversationParticipantPromise
  extends Promise<ConversationParticipant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  conversation: <T = ConversationPromise>() => T;
  role: () => Promise<ConversationParticipantRole>;
}

export interface ConversationParticipantSubscription
  extends Promise<AsyncIterator<ConversationParticipant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  conversation: <T = ConversationSubscription>() => T;
  role: () => Promise<AsyncIterator<ConversationParticipantRole>>;
}

export interface ConversationParticipantNullablePromise
  extends Promise<ConversationParticipant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  conversation: <T = ConversationPromise>() => T;
  role: () => Promise<ConversationParticipantRole>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface BlockListSubscriptionPayload {
  mutation: MutationType;
  node: BlockList;
  updatedFields: String[];
  previousValues: BlockListPreviousValues;
}

export interface BlockListSubscriptionPayloadPromise
  extends Promise<BlockListSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlockListPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlockListPreviousValuesPromise>() => T;
}

export interface BlockListSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlockListSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlockListSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlockListPreviousValuesSubscription>() => T;
}

export interface OrderableProductEdge {
  node: OrderableProduct;
  cursor: String;
}

export interface OrderableProductEdgePromise
  extends Promise<OrderableProductEdge>,
    Fragmentable {
  node: <T = OrderableProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderableProductEdgeSubscription
  extends Promise<AsyncIterator<OrderableProductEdge>>,
    Fragmentable {
  node: <T = OrderableProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BlockListPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BlockListPreviousValuesPromise
  extends Promise<BlockListPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlockListPreviousValuesSubscription
  extends Promise<AsyncIterator<BlockListPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateOrderLineItem {
  count: Int;
}

export interface AggregateOrderLineItemPromise
  extends Promise<AggregateOrderLineItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderLineItemSubscription
  extends Promise<AsyncIterator<AggregateOrderLineItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  firstName?: String;
  emailVerified?: Boolean;
  lastName?: String;
  phone?: String;
  roles: UserRole[];
  avatar?: String;
  last_login_date?: DateTimeOutput;
  stripeCustomerId?: String;
  oneSignalUserId?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  roles: () => Promise<UserRole[]>;
  avatar: () => Promise<String>;
  last_login_date: () => Promise<DateTimeOutput>;
  stripeCustomerId: () => Promise<String>;
  oneSignalUserId: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<UserRole[]>>;
  avatar: () => Promise<AsyncIterator<String>>;
  last_login_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  stripeCustomerId: () => Promise<AsyncIterator<String>>;
  oneSignalUserId: () => Promise<AsyncIterator<String>>;
}

export interface OrderLineItemConnection {
  pageInfo: PageInfo;
  edges: OrderLineItemEdge[];
}

export interface OrderLineItemConnectionPromise
  extends Promise<OrderLineItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderLineItemEdge>>() => T;
  aggregate: <T = AggregateOrderLineItemPromise>() => T;
}

export interface OrderLineItemConnectionSubscription
  extends Promise<AsyncIterator<OrderLineItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderLineItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderLineItemSubscription>() => T;
}

export interface BrandSubscriptionPayload {
  mutation: MutationType;
  node: Brand;
  updatedFields: String[];
  previousValues: BrandPreviousValues;
}

export interface BrandSubscriptionPayloadPromise
  extends Promise<BrandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrandPreviousValuesPromise>() => T;
}

export interface BrandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrandPreviousValuesSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BrandPreviousValues {
  id: ID_Output;
  name: String;
}

export interface BrandPreviousValuesPromise
  extends Promise<BrandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BrandPreviousValuesSubscription
  extends Promise<AsyncIterator<BrandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOptionValue {
  count: Int;
}

export interface AggregateOptionValuePromise
  extends Promise<AggregateOptionValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionValueSubscription
  extends Promise<AsyncIterator<AggregateOptionValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface OptionValueConnection {
  pageInfo: PageInfo;
  edges: OptionValueEdge[];
}

export interface OptionValueConnectionPromise
  extends Promise<OptionValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionValueEdge>>() => T;
  aggregate: <T = AggregateOptionValuePromise>() => T;
}

export interface OptionValueConnectionSubscription
  extends Promise<AsyncIterator<OptionValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionValueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionValueSubscription>() => T;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface OptionEdge {
  node: Option;
  cursor: String;
}

export interface OptionEdgePromise extends Promise<OptionEdge>, Fragmentable {
  node: <T = OptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionEdgeSubscription
  extends Promise<AsyncIterator<OptionEdge>>,
    Fragmentable {
  node: <T = OptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  firstName?: String;
  emailVerified?: Boolean;
  lastName?: String;
  phone?: String;
  roles: UserRole[];
  avatar?: String;
  last_login_date?: DateTimeOutput;
  stripeCustomerId?: String;
  oneSignalUserId?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  selectedShop: <T = ShopPromise>() => T;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  roles: () => Promise<UserRole[]>;
  avatar: () => Promise<String>;
  last_login_date: () => Promise<DateTimeOutput>;
  conversations: <T = FragmentableArray<ConversationParticipant>>(args?: {
    where?: ConversationParticipantWhereInput;
    orderBy?: ConversationParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cart: <T = FragmentableArray<OrderLineItem>>(args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeCustomerId: () => Promise<String>;
  oneSignalUserId: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  selectedShop: <T = ShopSubscription>() => T;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<UserRole[]>>;
  avatar: () => Promise<AsyncIterator<String>>;
  last_login_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  conversations: <
    T = Promise<AsyncIterator<ConversationParticipantSubscription>>
  >(args?: {
    where?: ConversationParticipantWhereInput;
    orderBy?: ConversationParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cart: <T = Promise<AsyncIterator<OrderLineItemSubscription>>>(args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeCustomerId: () => Promise<AsyncIterator<String>>;
  oneSignalUserId: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  selectedShop: <T = ShopPromise>() => T;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  roles: () => Promise<UserRole[]>;
  avatar: () => Promise<String>;
  last_login_date: () => Promise<DateTimeOutput>;
  conversations: <T = FragmentableArray<ConversationParticipant>>(args?: {
    where?: ConversationParticipantWhereInput;
    orderBy?: ConversationParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cart: <T = FragmentableArray<OrderLineItem>>(args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeCustomerId: () => Promise<String>;
  oneSignalUserId: () => Promise<String>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface ConversationSubscriptionPayload {
  mutation: MutationType;
  node: Conversation;
  updatedFields: String[];
  previousValues: ConversationPreviousValues;
}

export interface ConversationSubscriptionPayloadPromise
  extends Promise<ConversationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConversationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConversationPreviousValuesPromise>() => T;
}

export interface ConversationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConversationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConversationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConversationPreviousValuesSubscription>() => T;
}

export interface ConversationParticipantEdge {
  node: ConversationParticipant;
  cursor: String;
}

export interface ConversationParticipantEdgePromise
  extends Promise<ConversationParticipantEdge>,
    Fragmentable {
  node: <T = ConversationParticipantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConversationParticipantEdgeSubscription
  extends Promise<AsyncIterator<ConversationParticipantEdge>>,
    Fragmentable {
  node: <T = ConversationParticipantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ConversationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  conversationType: ConversationType;
}

export interface ConversationPreviousValuesPromise
  extends Promise<ConversationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  conversationType: () => Promise<ConversationType>;
}

export interface ConversationPreviousValuesSubscription
  extends Promise<AsyncIterator<ConversationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  conversationType: () => Promise<AsyncIterator<ConversationType>>;
}

export interface AggregateConversation {
  count: Int;
}

export interface AggregateConversationPromise
  extends Promise<AggregateConversation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConversationSubscription
  extends Promise<AsyncIterator<AggregateConversation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockList {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BlockListPromise extends Promise<BlockList>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  blockedUser: <T = UserPromise>() => T;
}

export interface BlockListSubscription
  extends Promise<AsyncIterator<BlockList>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  blockedUser: <T = UserSubscription>() => T;
}

export interface BlockListNullablePromise
  extends Promise<BlockList | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  blockedUser: <T = UserPromise>() => T;
}

export interface ConversationConnection {
  pageInfo: PageInfo;
  edges: ConversationEdge[];
}

export interface ConversationConnectionPromise
  extends Promise<ConversationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConversationEdge>>() => T;
  aggregate: <T = AggregateConversationPromise>() => T;
}

export interface ConversationConnectionSubscription
  extends Promise<AsyncIterator<ConversationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConversationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConversationSubscription>() => T;
}

export interface ConversationParticipantSubscriptionPayload {
  mutation: MutationType;
  node: ConversationParticipant;
  updatedFields: String[];
  previousValues: ConversationParticipantPreviousValues;
}

export interface ConversationParticipantSubscriptionPayloadPromise
  extends Promise<ConversationParticipantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConversationParticipantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConversationParticipantPreviousValuesPromise>() => T;
}

export interface ConversationParticipantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConversationParticipantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConversationParticipantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ConversationParticipantPreviousValuesSubscription
  >() => T;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ConversationParticipantPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  role: ConversationParticipantRole;
}

export interface ConversationParticipantPreviousValuesPromise
  extends Promise<ConversationParticipantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  role: () => Promise<ConversationParticipantRole>;
}

export interface ConversationParticipantPreviousValuesSubscription
  extends Promise<AsyncIterator<ConversationParticipantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  role: () => Promise<AsyncIterator<ConversationParticipantRole>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface AggregateAttribute {
  count: Int;
}

export interface AggregateAttributePromise
  extends Promise<AggregateAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttributeSubscription
  extends Promise<AsyncIterator<AggregateAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrandEdge {
  node: Brand;
  cursor: String;
}

export interface BrandEdgePromise extends Promise<BrandEdge>, Fragmentable {
  node: <T = BrandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrandEdgeSubscription
  extends Promise<AsyncIterator<BrandEdge>>,
    Fragmentable {
  node: <T = BrandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface AggregateBlockList {
  count: Int;
}

export interface AggregateBlockListPromise
  extends Promise<AggregateBlockList>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlockListSubscription
  extends Promise<AsyncIterator<AggregateBlockList>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessagePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  messageType: MessageType;
  message: String;
  attachmentThumbUrl?: String;
  attachmentUrl?: String;
  isDeleted: Boolean;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  messageType: () => Promise<MessageType>;
  message: () => Promise<String>;
  attachmentThumbUrl: () => Promise<String>;
  attachmentUrl: () => Promise<String>;
  isDeleted: () => Promise<Boolean>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  messageType: () => Promise<AsyncIterator<MessageType>>;
  message: () => Promise<AsyncIterator<String>>;
  attachmentThumbUrl: () => Promise<AsyncIterator<String>>;
  attachmentUrl: () => Promise<AsyncIterator<String>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateVariant {
  count: Int;
}

export interface AggregateVariantPromise
  extends Promise<AggregateVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVariantSubscription
  extends Promise<AsyncIterator<AggregateVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttributeEdge {
  node: Attribute;
  cursor: String;
}

export interface AttributeEdgePromise
  extends Promise<AttributeEdge>,
    Fragmentable {
  node: <T = AttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttributeEdgeSubscription
  extends Promise<AsyncIterator<AttributeEdge>>,
    Fragmentable {
  node: <T = AttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionSubscriptionPayload {
  mutation: MutationType;
  node: Option;
  updatedFields: String[];
  previousValues: OptionPreviousValues;
}

export interface OptionSubscriptionPayloadPromise
  extends Promise<OptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionPreviousValuesPromise>() => T;
}

export interface OptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionPreviousValuesSubscription>() => T;
}

export interface ShopConnection {
  pageInfo: PageInfo;
  edges: ShopEdge[];
}

export interface ShopConnectionPromise
  extends Promise<ShopConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShopEdge>>() => T;
  aggregate: <T = AggregateShopPromise>() => T;
}

export interface ShopConnectionSubscription
  extends Promise<AsyncIterator<ShopConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShopEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShopSubscription>() => T;
}

export interface OptionPreviousValues {
  id: ID_Output;
  name: String;
}

export interface OptionPreviousValuesPromise
  extends Promise<OptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OptionPreviousValuesSubscription
  extends Promise<AsyncIterator<OptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SelectedOptionConnection {
  pageInfo: PageInfo;
  edges: SelectedOptionEdge[];
}

export interface SelectedOptionConnectionPromise
  extends Promise<SelectedOptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SelectedOptionEdge>>() => T;
  aggregate: <T = AggregateSelectedOptionPromise>() => T;
}

export interface SelectedOptionConnectionSubscription
  extends Promise<AsyncIterator<SelectedOptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SelectedOptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSelectedOptionSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrderableProduct {
  count: Int;
}

export interface AggregateOrderableProductPromise
  extends Promise<AggregateOrderableProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderableProductSubscription
  extends Promise<AsyncIterator<AggregateOrderableProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptionValueSubscriptionPayload {
  mutation: MutationType;
  node: OptionValue;
  updatedFields: String[];
  previousValues: OptionValuePreviousValues;
}

export interface OptionValueSubscriptionPayloadPromise
  extends Promise<OptionValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionValuePreviousValuesPromise>() => T;
}

export interface OptionValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionValuePreviousValuesSubscription>() => T;
}

export interface OrderLineItemEdge {
  node: OrderLineItem;
  cursor: String;
}

export interface OrderLineItemEdgePromise
  extends Promise<OrderLineItemEdge>,
    Fragmentable {
  node: <T = OrderLineItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderLineItemEdgeSubscription
  extends Promise<AsyncIterator<OrderLineItemEdge>>,
    Fragmentable {
  node: <T = OrderLineItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionValuePreviousValues {
  id: ID_Output;
  name: String;
}

export interface OptionValuePreviousValuesPromise
  extends Promise<OptionValuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OptionValuePreviousValuesSubscription
  extends Promise<AsyncIterator<OptionValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface AttributeConnection {
  pageInfo: PageInfo;
  edges: AttributeEdge[];
}

export interface AttributeConnectionPromise
  extends Promise<AttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttributeEdge>>() => T;
  aggregate: <T = AggregateAttributePromise>() => T;
}

export interface AttributeConnectionSubscription
  extends Promise<AsyncIterator<AttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttributeSubscription>() => T;
}

export interface AggregateOption {
  count: Int;
}

export interface AggregateOptionPromise
  extends Promise<AggregateOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionSubscription
  extends Promise<AsyncIterator<AggregateOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  totalPrice: Float;
  totalRefunded: Float;
  totalTax: Float;
  orderStatus: OrderStatus;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  totalPrice: () => Promise<Float>;
  totalRefunded: () => Promise<Float>;
  totalTax: () => Promise<Float>;
  orderStatus: () => Promise<OrderStatus>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
  totalRefunded: () => Promise<AsyncIterator<Float>>;
  totalTax: () => Promise<AsyncIterator<Float>>;
  orderStatus: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface ConversationParticipantConnection {
  pageInfo: PageInfo;
  edges: ConversationParticipantEdge[];
}

export interface ConversationParticipantConnectionPromise
  extends Promise<ConversationParticipantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConversationParticipantEdge>>() => T;
  aggregate: <T = AggregateConversationParticipantPromise>() => T;
}

export interface ConversationParticipantConnectionSubscription
  extends Promise<AsyncIterator<ConversationParticipantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ConversationParticipantEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateConversationParticipantSubscription>() => T;
}

export interface OrderableProduct {
  id: ID_Output;
  position: Int;
}

export interface OrderableProductPromise
  extends Promise<OrderableProduct>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  position: () => Promise<Int>;
  shopBestSeller: <T = ShopPromise>() => T;
  shopNewProduct: <T = ShopPromise>() => T;
}

export interface OrderableProductSubscription
  extends Promise<AsyncIterator<OrderableProduct>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  position: () => Promise<AsyncIterator<Int>>;
  shopBestSeller: <T = ShopSubscription>() => T;
  shopNewProduct: <T = ShopSubscription>() => T;
}

export interface OrderableProductNullablePromise
  extends Promise<OrderableProduct | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  position: () => Promise<Int>;
  shopBestSeller: <T = ShopPromise>() => T;
  shopNewProduct: <T = ShopPromise>() => T;
}

export interface Category {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  options: <T = FragmentableArray<Option>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shop: <T = ShopPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  options: <T = Promise<AsyncIterator<OptionSubscription>>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shop: <T = ShopSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  options: <T = FragmentableArray<Option>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shop: <T = ShopPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderLineItemSubscriptionPayload {
  mutation: MutationType;
  node: OrderLineItem;
  updatedFields: String[];
  previousValues: OrderLineItemPreviousValues;
}

export interface OrderLineItemSubscriptionPayloadPromise
  extends Promise<OrderLineItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderLineItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderLineItemPreviousValuesPromise>() => T;
}

export interface OrderLineItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderLineItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderLineItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderLineItemPreviousValuesSubscription>() => T;
}

export interface AggregateBrand {
  count: Int;
}

export interface AggregateBrandPromise
  extends Promise<AggregateBrand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrandSubscription
  extends Promise<AsyncIterator<AggregateBrand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderLineItemPreviousValues {
  id: ID_Output;
  deletedAt?: DateTimeOutput;
  quantity: Int;
}

export interface OrderLineItemPreviousValuesPromise
  extends Promise<OrderLineItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
}

export interface OrderLineItemPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderLineItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface BlockListEdge {
  node: BlockList;
  cursor: String;
}

export interface BlockListEdgePromise
  extends Promise<BlockListEdge>,
    Fragmentable {
  node: <T = BlockListPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlockListEdgeSubscription
  extends Promise<AsyncIterator<BlockListEdge>>,
    Fragmentable {
  node: <T = BlockListSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Variant {
  id: ID_Output;
  deletedAt?: DateTimeOutput;
  price: Float;
  available: Boolean;
}

export interface VariantPromise extends Promise<Variant>, Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
  selectedOptions: <T = FragmentableArray<SelectedOption>>(args?: {
    where?: SelectedOptionWhereInput;
    orderBy?: SelectedOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  price: () => Promise<Float>;
  available: () => Promise<Boolean>;
  product: <T = ProductPromise>() => T;
}

export interface VariantSubscription
  extends Promise<AsyncIterator<Variant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  selectedOptions: <
    T = Promise<AsyncIterator<SelectedOptionSubscription>>
  >(args?: {
    where?: SelectedOptionWhereInput;
    orderBy?: SelectedOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  price: () => Promise<AsyncIterator<Float>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  product: <T = ProductSubscription>() => T;
}

export interface VariantNullablePromise
  extends Promise<Variant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
  selectedOptions: <T = FragmentableArray<SelectedOption>>(args?: {
    where?: SelectedOptionWhereInput;
    orderBy?: SelectedOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  price: () => Promise<Float>;
  available: () => Promise<Boolean>;
  product: <T = ProductPromise>() => T;
}

export interface AggregateShop {
  count: Int;
}

export interface AggregateShopPromise
  extends Promise<AggregateShop>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShopSubscription
  extends Promise<AsyncIterator<AggregateShop>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderableProductSubscriptionPayload {
  mutation: MutationType;
  node: OrderableProduct;
  updatedFields: String[];
  previousValues: OrderableProductPreviousValues;
}

export interface OrderableProductSubscriptionPayloadPromise
  extends Promise<OrderableProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderableProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderableProductPreviousValuesPromise>() => T;
}

export interface OrderableProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderableProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderableProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderableProductPreviousValuesSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderableProductPreviousValues {
  id: ID_Output;
  position: Int;
}

export interface OrderableProductPreviousValuesPromise
  extends Promise<OrderableProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  position: () => Promise<Int>;
}

export interface OrderableProductPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderableProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  position: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Option {
  id: ID_Output;
  name: String;
}

export interface OptionPromise extends Promise<Option>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  values: <T = FragmentableArray<OptionValue>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategoryPromise>() => T;
  shop: <T = ShopPromise>() => T;
}

export interface OptionSubscription
  extends Promise<AsyncIterator<Option>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  values: <T = Promise<AsyncIterator<OptionValueSubscription>>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategorySubscription>() => T;
  shop: <T = ShopSubscription>() => T;
}

export interface OptionNullablePromise
  extends Promise<Option | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  values: <T = FragmentableArray<OptionValue>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategoryPromise>() => T;
  shop: <T = ShopPromise>() => T;
}

export interface OptionConnection {
  pageInfo: PageInfo;
  edges: OptionEdge[];
}

export interface OptionConnectionPromise
  extends Promise<OptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionEdge>>() => T;
  aggregate: <T = AggregateOptionPromise>() => T;
}

export interface OptionConnectionSubscription
  extends Promise<AsyncIterator<OptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionSubscription>() => T;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ConversationEdge {
  node: Conversation;
  cursor: String;
}

export interface ConversationEdgePromise
  extends Promise<ConversationEdge>,
    Fragmentable {
  node: <T = ConversationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConversationEdgeSubscription
  extends Promise<AsyncIterator<ConversationEdge>>,
    Fragmentable {
  node: <T = ConversationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  name: String;
  description?: String;
  SKU?: String;
  displayPrice: Float;
  available: Boolean;
  imageUrl?: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  SKU: () => Promise<String>;
  displayPrice: () => Promise<Float>;
  available: () => Promise<Boolean>;
  imageUrl: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  SKU: () => Promise<AsyncIterator<String>>;
  displayPrice: () => Promise<AsyncIterator<Float>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
}

export interface BrandConnection {
  pageInfo: PageInfo;
  edges: BrandEdge[];
}

export interface BrandConnectionPromise
  extends Promise<BrandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrandEdge>>() => T;
  aggregate: <T = AggregateBrandPromise>() => T;
}

export interface BrandConnectionSubscription
  extends Promise<AsyncIterator<BrandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrandSubscription>() => T;
}

export interface SelectedOption {
  id: ID_Output;
  deletedAt?: DateTimeOutput;
}

export interface SelectedOptionPromise
  extends Promise<SelectedOption>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
  option: <T = OptionPromise>() => T;
  variant: <T = VariantPromise>() => T;
  value: <T = OptionValuePromise>() => T;
}

export interface SelectedOptionSubscription
  extends Promise<AsyncIterator<SelectedOption>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  option: <T = OptionSubscription>() => T;
  variant: <T = VariantSubscription>() => T;
  value: <T = OptionValueSubscription>() => T;
}

export interface SelectedOptionNullablePromise
  extends Promise<SelectedOption | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
  option: <T = OptionPromise>() => T;
  variant: <T = VariantPromise>() => T;
  value: <T = OptionValuePromise>() => T;
}

export interface AggregateSelectedOption {
  count: Int;
}

export interface AggregateSelectedOptionPromise
  extends Promise<AggregateSelectedOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSelectedOptionSubscription
  extends Promise<AsyncIterator<AggregateSelectedOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptionValueEdge {
  node: OptionValue;
  cursor: String;
}

export interface OptionValueEdgePromise
  extends Promise<OptionValueEdge>,
    Fragmentable {
  node: <T = OptionValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionValueEdgeSubscription
  extends Promise<AsyncIterator<OptionValueEdge>>,
    Fragmentable {
  node: <T = OptionValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ShopSubscriptionPayload {
  mutation: MutationType;
  node: Shop;
  updatedFields: String[];
  previousValues: ShopPreviousValues;
}

export interface ShopSubscriptionPayloadPromise
  extends Promise<ShopSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShopPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShopPreviousValuesPromise>() => T;
}

export interface ShopSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShopSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShopSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShopPreviousValuesSubscription>() => T;
}

export interface OptionValue {
  id: ID_Output;
  name: String;
}

export interface OptionValuePromise extends Promise<OptionValue>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OptionValueSubscription
  extends Promise<AsyncIterator<OptionValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface OptionValueNullablePromise
  extends Promise<OptionValue | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SelectedOptionPreviousValues {
  id: ID_Output;
  deletedAt?: DateTimeOutput;
}

export interface SelectedOptionPreviousValuesPromise
  extends Promise<SelectedOptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deletedAt: () => Promise<DateTimeOutput>;
}

export interface SelectedOptionPreviousValuesSubscription
  extends Promise<AsyncIterator<SelectedOptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SelectedOptionSubscriptionPayload {
  mutation: MutationType;
  node: SelectedOption;
  updatedFields: String[];
  previousValues: SelectedOptionPreviousValues;
}

export interface SelectedOptionSubscriptionPayloadPromise
  extends Promise<SelectedOptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SelectedOptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SelectedOptionPreviousValuesPromise>() => T;
}

export interface SelectedOptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SelectedOptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SelectedOptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SelectedOptionPreviousValuesSubscription>() => T;
}

export interface AggregateConversationParticipant {
  count: Int;
}

export interface AggregateConversationParticipantPromise
  extends Promise<AggregateConversationParticipant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConversationParticipantSubscription
  extends Promise<AsyncIterator<AggregateConversationParticipant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderableProductConnection {
  pageInfo: PageInfo;
  edges: OrderableProductEdge[];
}

export interface OrderableProductConnectionPromise
  extends Promise<OrderableProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderableProductEdge>>() => T;
  aggregate: <T = AggregateOrderableProductPromise>() => T;
}

export interface OrderableProductConnectionSubscription
  extends Promise<AsyncIterator<OrderableProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderableProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderableProductSubscription>() => T;
}

export interface VariantConnection {
  pageInfo: PageInfo;
  edges: VariantEdge[];
}

export interface VariantConnectionPromise
  extends Promise<VariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VariantEdge>>() => T;
  aggregate: <T = AggregateVariantPromise>() => T;
}

export interface VariantConnectionSubscription
  extends Promise<AsyncIterator<VariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVariantSubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Conversation",
    embedded: false
  },
  {
    name: "ConversationParticipant",
    embedded: false
  },
  {
    name: "ConversationParticipantRole",
    embedded: false
  },
  {
    name: "ConversationType",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "MessageType",
    embedded: false
  },
  {
    name: "BlockList",
    embedded: false
  },
  {
    name: "Brand",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Attribute",
    embedded: false
  },
  {
    name: "Option",
    embedded: false
  },
  {
    name: "OptionValue",
    embedded: false
  },
  {
    name: "SelectedOption",
    embedded: false
  },
  {
    name: "Variant",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "OrderLineItem",
    embedded: false
  },
  {
    name: "Shop",
    embedded: false
  },
  {
    name: "OrderableProduct",
    embedded: false
  },
  {
    name: "OrderStatus",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
